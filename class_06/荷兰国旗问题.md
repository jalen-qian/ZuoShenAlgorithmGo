# 荷兰国旗问题
## 一.简易版荷兰国旗问题

给定一个数组`arr`和一个数`x`，将这个数组划分为 <=x 的在左边 >x 的数在右边
要求：1.时间复杂度O(N) 2.除了少数几个变量，不分配额外空间

### 思路
我们规定一个左侧小于区域，初始时小于区域的位置在 -1 位置（还没扩进去任何数），准备一个变量`i`,初始时在0位置。并在`i<=len(arr)-1`的条件下处理以下逻辑：
1. 如果 `nums[i] <= x`，则将i位置与小于区域右侧的位置交换，并将小于区域往右扩一个位置，`i`跳下一个位置。
2. 如果 `nums[i] > x`，小于区域不变，`i`跳下一个位置。

## 二.复杂版荷兰国旗问题
我们改下要求，规定 <x 的在左边， ==x 的在中间区域，>x 的在右边。

### 思路
我们规定一个左侧的小于区域和右侧的大于区域。
1. 如果 `nums[i] <  x`，则将i位置与小于区域右侧的位置交换，并将小于区域往右扩一个位置，`i`跳下一个位置。
2. 如果 `nums[i] == x`，则不做处理，i跳下一个位置。
3. 如果 `nums[i] >  x`，则将i位置与大于区域左侧的位置交换，并将大于区域往左扩一个位置，**`i`留在原地**。
4. 直到 i == 右侧区域（i与右侧区域碰撞上），就停止循环。

注意：
> 如果发现i位置 > x，则将i位置与大于区域左侧交换，i要定在原地，不能往下一个跳，因为**换过来的数还没有看过，需要重复看一遍**。<br>
> 但是如果发现i位置 < x，将i位置与小于区域右侧交换后，i可以往下一个跳。因为小于区域右侧一定在i的左边，这些数一定都是被看过的，要么比x小被小于区域扩进去了，要么等于x。

## 三.复杂版荷兰国旗问题2
在上述复杂版荷兰国旗问题的基础上，不提供x，而是用传入数组的最后一个数当做x。
最终让数组`nums`中，< nums[length-1] 的在左边，== nums[length-1] 的在中间，> nums[length-1] 的在右边。

### 思路：
我们先将右侧区域先把最后一个数(`n-1位置的数`)扩进去，相当于在`[0~n-2]`范围内先求解荷兰国旗问题。然后再将最后一个数与右侧区域的位置交换。

代码实现如下：
[code01_flag_of_netherlands.go](code01_flag_of_netherlands.go)