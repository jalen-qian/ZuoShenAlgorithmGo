# 快速排序
前面已经知道了荷兰国旗的流程。利用荷兰国旗和递归的思想，能实现快速排序的流程。

# 快速排序1.0
**思路：**<br>
荷兰国旗将 <x 的放左边，=x 的放中间，>x 的放右边，对于整个数组来说，x位置定下来了，因为整体排好序之后，<x 的一定在x左边，>x的一定在x右边。

如果我们每次执行`NetherlandsFlag2`，都获取到x定位到的位置，比如是i位置。那么我们将数组分为i位置左边区域和右边区域。并对这两个区域重复递归执行此过程。每次递归都能确定一个数在整个排好序之后的位置。最终数组肯定是排好序了。

## 具体实现过程
1. 实现一个荷兰国旗函数`NetherlandsFlag`,这个函数在对最右侧的数x执行完荷兰国旗后，返回最右侧x最终的位置。
2. 定义一个函数`process1(nums []int, L,R int)`，这个函数会让`nums`在`L-R`上排好序。
3. 在`process1`中执行以下过程：
   - 1.先执行`NetherlandsFlag`，并获取到位置i.
   - 2.进行二分，分为左侧区域 `L~i-1` 和 右侧区域`i+1 ~ R`，并分别递归调用process1。

## 代码实现
[code02_quick_sort.go](code02_quick_sort.go)

# 快速排序2.0版本
**小优化：**<br>
我们发现，每次递归过程中，执行完`NetherlandsFlag`之后，只会确定1个x的位置，而假如x有很多个，那么其实这些x的位置都是最终确定的，不会再变。
我们可以让`NetherlandsFlag`返回一个坐标数组`int[2]`，返回的值是个数组，表示等于x的中间区域的下标。

比如，执行完`NetherlandsFlag`之后，返回了{3,5}，说明3到5位置都是x，我们下一次划分时，只需要划分为 `L~2` 和 `6~R` 两个区域。

举个具体的例子:

比如数组`[5,2,3,7,4,9,6,2,8,1,9,3]`，最后一个数是3，会对3进行荷兰国旗流程，变成：
```
[2,1,2,3,3,3,5,9,7,8,6,4]
       i   j
```
那么接下来的子过程肯定是`[0~2]` 和 `[6~11]` 两个子区间中执行process。

## 时间复杂度分析：
先说结论：**快排1.0和2.0的时间复杂度都是O(N^2)**。

这是因为我们估计时间复杂度，必须看最差的情况。而最差情况是，这个数组本身就是有序的，这时快排1.0和2.0的时间复杂度必然会命中O(N^2)。这时为啥呢？

我们举个例子：
```
假如我们有个数组是[1,2,3,4,5,6,7,8]
第1次的过程，x是8，荷兰国旗会依次从1看到8，看8次，不会改变顺序，但划分子数组是[1,2,3,4,5,6,7]和[]（右边是空的）
第2次的过程，x是7，荷兰国旗会依次从1看到7，看7次
同理：
第3次，看6次
第4次，看5次
...

总共操作的次数是个等差数列，所以复杂度是O(N^2)
```

# 快排3.0，随机快排
我们可以看到，快排2.0最差的情况，每次都取最右侧的数，每次都打到最右边，所以时间复杂度是O(N^2)。

如果我们每次取数时，不取最右边，而是在子区间任意一个位置找一个数作为x，即使是最差的情况，每次也只有`1/N`（N是子过程的区间大小）的概率打到最右边。

快速排序最好情况是每次都打到中间，**越往边上偏移，下次递归的子过程的数据规模就越大**。而随机快排，打到每个位置的概率都是1/N。这就成为了一个概率上
的数学期望的问题。已经有数学家证明了，随机快排，**子过程在概率上的数学期望**是O(logN)规模的。

所以随机快排的时间复杂度是O(N * logN)。

## 实现方法
我们只需要快排2.0的荷兰国旗函数中，先生成一个 L-R位置的随机数，并与R位置交换。

# 用非递归的方式实现快排3.0
快速排序中每次process都会获取到一个子过程的范围，我们只需要将这个返回记录下来，丢到一个栈中。

# 代码实现
快排1.0：[code02_quick_sort.go](code02_quick_sort.go#L13)

快排2.0：[code02_quick_sort.go](code02_quick_sort.go#L67)

快排3.0：[code02_quick_sort.go](code02_quick_sort.go#L122)

非递归方式实现快排：[code02_quick_sort_stack.go](code02_quick_sort_stack.go)