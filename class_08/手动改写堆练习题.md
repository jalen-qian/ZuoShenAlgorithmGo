# 手写堆
很多语言提供的堆结构，只能提供这几个最基本的功能：
1. 向堆中push一个元素
2. 从堆中Pop一个元素
3. 获取堆顶的元素
4. 获取堆的大小
   Go语言提供的堆，提供了`Push`,`Pop`,`Remove`和`Fix`4个功能，还算比较全面的。有时候我们需要使用堆的额外的功能时，只能手动实现了，这里就需要手写堆。

比如，我们给了堆一个对象，已经被添加到堆中了，之后我们将这个对象的属性变了，且这个属性是参与堆的排序的，此时我们希望这个堆能将这个对象重新调整到正确的位置。此时系统的堆是无法实现的，因为系统提供的堆没有**反向索引表**。

例如你把`a`这个对象的年龄属性，从18改成了30，系统堆做不到调整，因为要调整，需要先知道`a`对象在数组中的位置，然后在`a`所在的位置，执行`heapify`往上调整，或者`heapInsert`往下调整。

如果一定要做到，只能一个个遍历先找到`a`的位置，这样时间复杂度就是O(N)了，而不是O(logN)了。

我们要实现这个功能，就要手写堆，**在堆中维护一个反向索引表**，记住每个元素在堆中的位置。

## 代码实现
代码详见[code06_heap_greater.go](code06_heap_greater.go)，在这个手写的堆结构，提供了系统堆不具备的额外的功能：
1. `Contains(obj T) bool`获取某个对象是否在堆中
2. `Remove(obj T)`删除堆中的某个对象
3. `Resign(obj T)`假如我改变了某个对象的值，这个对象在堆中，并且这个值是影响比较大小的，改完就不符合堆结构了，让堆重新调整成堆结构

这些额外的功能的时间复杂度都是O(logN)级别的。

# 练习题1
## 题目描述
给定一个整型数组，int[] arr；和一个布尔类型数组，boolean[] op

两个数组一定等长，假设长度为N，arr[i]表示客户编号，op[i]表示客户操作
> arr = [ 3, 3, 1, 2, 1, 2, 5… <br>
> op  = [ T, T, T, T, F, T, F…

依次表示：3用户购买了一件商品，3用户购买了一件商品，1用户购买了一件商品，2用户购买了一件商品，1用户退货了一件商品，2用户购买了一件商品，5用户退货了一件商品…

一对`arr[i]`和`op[i]`就代表一个事件：
- 用户号为arr[i]，op[i] == T就代表这个用户购买了一件商品
- op[i] == F就代表这个用户退货了一件商品

现在你作为电商平台负责人，你想在每一个事件到来的时候，
**都给购买次数最多的前K名用户颁奖**。
所以每个事件发生后，你都需要一个得奖名单（得奖区）。

得奖系统的规则：
1. 如果某个用户购买商品数为0，但是又发生了退货事件， **则认为该事件无效**，得奖名单和上一个事件发生后一致，例子中的5用户
2. 某用户发生购买商品事件，购买商品数+1，发生退货事件，购买商品数-1
3. 每次都是最多K个用户得奖，K也为传入的参数。 如果根据全部规则，得奖人数确实不够K个，那就以不够的情况输出结果
4. 得奖系统分为得奖区和候选区，任何用户只要购买数>0，**一定在这两个区域中的一个**
5. 购买数最大的前K名用户进入得奖区， 在最初时如果得奖区没有到达K个用户，那么新来的用户直接进入得奖区
6. 如果购买数不足以进入得奖区的用户，进入候选区
7. 如果候选区购买数最多的用户，已经足以进入得奖区， 
**该用户就会替换得奖区中购买数最少的用户**（大于才能替换），
如果得奖区中购买数最少的用户有多个，就**替换最早进入得奖区的用户**
如果候选区中购买数最多的用户有多个，**机会会给最早进入候选区的用户**
8. 候选区和得奖区是两套时间，
因用户只会在其中一个区域，所以只会有一个区域的时间，另一个没有。从得奖区出来进入候选区的用户，得奖区时间删除。<br>
进入候选区的时间就是当前事件的时间（可以理解为arr[i]和op[i]中的i）<br>
从候选区出来进入得奖区的用户，候选区时间删除，<br>
进入得奖区的时间就是当前事件的时间（可以理解为arr[i]和op[i]中的i）

请遍历arr数组和op数组，遍历每一步输出一个得奖名单
```go
func TopK (arr []int, op []bool, int k)[][]int {}
```

## 实现
### 1.使用暴力方法实现
代码详见：[code07_every_step_show_boss.go](../class_07/code07_every_step_show_boss.go#L171)
#### 时间复杂度
暴力方法使用数组存得奖区和候选区的元素，遍历过程中，每次候选区的区域会进行排序排序过程是 O(N*logN)，每次还会进行一次删除购买数为0的用户，这个会遍历一遍，时间复杂度是O(N)
其他的操作都是常数时间，整体看时间复杂度是O(N^2 * logN)

### 2. 使用手写堆方式实现
代码详见：[code07_every_step_show_boss.go](../class_07/code07_every_step_show_boss.go#L53)
#### 时间复杂度
手写堆方式将得奖区和候选区存储在堆中，其中得奖区堆的大小是k，每次遍历调整的代价是O(logK)，候选区的堆大小与元素数量N是一个级别的。每次调整的代价是O(logN)，所以整体的时间复杂度是O(N*logN)
