# 桶排序（基于容器的排序，计数排序 & 基数排序）
## 1. 计数排序
计数排序要求样本只能是整数，且限定取值范围。比如给定一个整数数组，数组中的数取值范围是[0-100]，这种情况下可以使用计数排序，流程如下：
1. 准备一个长度101的数组整数，用来统计数组中每个数出现的次数。
2. 遍历原始数组，遇到一个数，计数数组中对应位置的数加1，比如遇到10，则 count[10]++
3. 从小到大遍历计数的数组，如果遇到数量为0，则跳过，否则，有多少个，就回填多少当前数到原始数组。

注意：样本数范围不会在参数中传入，只需要遍历一遍就能获取到，但是既然使用计数排序，肯定已经限定了数的取值范围。

### 计数排序举例
比如数组 `arr := []int{0,0,10,5,2,3,6,8,2,9,7,1}`，给定这个数组取值范围是0-10。<br>
则过程如下：
```
1. 生成辅助数组count，长度是11,分别统计数字0-10的出现次数
2. 遍历arr，会发现0出现2次，10出现1次，5出现1次，等等，遍历后得到的count如下：
   count = [2,1,2,1,0,1,1,1,1,1,1}
            0 1 2 3 4 5 6 7 8 9 10
3. 遍历count，因为0出现两次，所以回填两个0,1出现1次回填1个1，2出现两次，回填两个2...
4. 最后得到的arr数组就是 [0,0,1,2,2,3,5,6,7,8,9,10]，排好序了。
```

### 优缺点：
优点：时间复杂度是O(N)，我们只遍历了两次，额外空间复杂度是O(M)，额外分配了M的辅助统计数组(M是取值范围的大小)

缺点：对数据有严格要求，只能是数字且还对取值范围有要求，扩展性不强。

## 2. 基数排序
基数排序是另一种基于容器结构的排序，基数排序也对数据样本有要求，同样要求是整数，但不再对样本范围有要求，而是要求给定样本的最大位数。
比如给定一个整数数组，告诉你里面的数最大是3位数的（也就是最大不超过999），那么可以用基数排序。流程如下：
1. 我们将所有不足3位的数前面补0，搞成3位，比如遇到21，补成021，遇到5补成005（逻辑上这么理解，代码不需要这一步）
2. 我们准备10个桶，分别表示数字0-9，桶是**队列结构，先进先出**。
3. 先将个位排好序，遍历数组，个位数是0的，进0号桶，个位数是1的进1号桶，依此类推。全部进桶之后，从0号到9号遍历桶，并将不空的桶重新倒回原始数组，此时**个位数上面就全部排好序了**
4. 再将十位排好序，遍历数组，十位数是0的，进0号桶，十位数是1的进1号桶，依此类推。全部进桶之后，从0号到9号遍历桶，并将不空的桶重新倒回原始数组，此时**十位数上面也全部排好序了**
5. 最后将百位排好序，重复上面的入桶和出桶的过程，此时全部数排好序。

### 基数排序举例
比如规定最大3位整数的数组`arr := []int{356,005,731,044,802,003,059,009}，过程如下
```
1. 准备0~9一共10个桶，并按照个位数依此入桶，入桶后的样子如下：

      731 802 003 044 005 356         059
                                      009
   0   1   2   3   4   5   6   7   8   9

  依次将桶中的数字倒回arr数组，则arr变成：
 arr = [731,802,003,044,005,356,009,059]  注意009是先入桶的，先出，桶是队列结构
   此时我们发现数组中的数字，个位数变得有序了。
   
2. 重复上面的步骤，按照十位入桶和出桶，入桶后的样子如下：
  009
  005
  003                 059
  802         731 044 356
   0   1   2   3   4   5   6   7   8   9
  再次依次将桶中的数字倒出，如下：
 arr = [802,003,005,009,731,044,356,059]
 
3. 最后将百位的数入桶和出桶，入桶后如下
  059
  044
  009
  005
  003         356             731 802
   0   1   2   3   4   5   6   7   8   9
  再次倒出桶，arr已经整体排好序了：
 arr = [003,005,009,044,059,356,731,802]

```

### 基数排序解释
个位数入桶和出桶，会将个位上的数按照从小到大排好了序。而十位入桶的顺序是上次排好序之后的，出桶又是按照先进先出，所以十位数出桶时，保留了个位数的相对顺序。比如两个十位都是5的数，先进5号桶的，一定个位比较小，出去时这个数也会排前面（比如上面的056和359）。
所有位数都执行完后，整体就有序了。

### 总结：
基数排序的时间复杂度是O(N)的，额外空间复杂度是O(N)（10个桶每次最多装了全部的数进去，又全部倒出）。也有流程能优化，将这个入桶出桶的过程优化成O(1)的，后续会在代码中展示。

缺点：同样对样本有严格要求。

## 代码实现
1. 计数排序 [code02_count_sort.go](code02_count_sort.go)
2. 基数排序使用队列的版本
3. 基数排序优化版

# 排序算法的稳定性
## 1.稳定性的定义
如果一个排序算法在排好序之后，那些相同的值的相对位置没有变，则说这个排序算法是稳定的，具有稳定性。

首先说明，如果排序的是基本数据类型，则稳定性没有意义，因为基本数据类型只有值本身有意义，相等的值交换了也没有影响，**排序基本数据类型，则一定是稳定的**。

比如对员工数组按照年龄排序，有3个员工，分别是 {"张三", 50}, {"李四", 30}, {"王五", 30}，按照年龄排序，则
30岁的两个员工排前面，张三50岁排后面。

如果某个排序算法能保证排好序后，李四仍然在张三前面，则这个排序算法是稳定的。

注意：这里的有稳定性是指，这个排序流程代码有策略能做到不破坏相对次序，如果真实的代码实现不这么做，可能就无稳定性。只要有办法能做到稳定就说这个算法有稳定性。

比如归并排序，左右两边的数组做merge的过程，如果遇到相同的数，**总是先拷贝左边**，则有稳定性。如果总是拷贝右边，则没有稳定性。
但是因为我们能实现成有稳定性的代码，所以说归并排序是稳定的。

## 2. 常见算法的稳定性分析

1. 选择排序**无稳定性**。选择排序流程是0~N-1找到最小值放0位置，1~N-1找最小值放1位置，依此类推，直到排好序。<br>
   假如arr=[5,5,5,5,5,3]，找到最小值3后，会和第1个5交换，第1个5换到了最后，破坏了相对顺序，所以不稳定。
2. 冒泡排序**有稳定性**。冒泡流程中不断将较大的数交换到右边，交换过程并没破坏相对顺序。
3. 插入排序**有稳定性**。插入排序保证0-i有序，从i不断往前看，只有比前一个数小，才和前面的数交换，相等不会交换，没有破坏相对顺序，稳定。
4. 归并排序**有稳定性**。原因前面已经提到了。
5. 随机快排**无稳定性**。因为在执行荷兰国旗问题流程中，当前数与小于区域前的数交换，必定会破坏相对顺序。<br>
   比如：`[2,3,3,1,2)5,5,5,2...]` 判定标准是3，当前遍历到5后面的2，此时2与小于区域前的5交换，这个5就跑到了剩余两个5的后面，破坏了相对顺序。
6. 堆排序**无稳定性**。因为在调整堆结构的过程中，相对顺序可能会改变。
7. 不基于比较的计数排序和基数排序，由于只能排序整数，所以是稳定的。

总结如下：

| 排序算法  | 时间复杂度     | 额外空间复杂度 | 稳定性 |
|-------|-----------|---------|-----|
| 选择排序  | O(N^2)    | O(1)    | 无   |
| 冒泡排序  | O(N^2)    | O(1)    | 有   |
| 插入排序  | O(N^2)    | O(1)    | 有   |
| 归并排序  | O(N*logN) | O(N)    | 有   |
| 随机快排  | O(N*logN) | O(logN) | 无   |
| 堆排序   | O(N*logN) | O(1)    | 无   |
| 计数排序  | O(N)      | O(M)    | 有   |
| 基数排序  | O(N)      | O(N)    | 有   |


## 3. 排序总结
1. 不基于比较的排序，对样本数据有严格要求，不易改写
2. 基于比较的排序，只要规定好两个样本怎么比大小就可以直接复用
3. 基于比较的排序，时间复杂度的极限是O(N*logN)
4. 时间复杂度O(N*logN)、额外空间复杂度低于O(N)、且稳定的基于比较的排序是不存在的。
5. 为了绝对的速度选快排、为了省空间选堆排、为了稳定性选归并

## 4. 排序常见的坑
1. 出现过这样一个面试题：在整型数组中，请把奇数放在数组左边，偶数放在数组右边，要求所有奇数之间原始的相对次序不变，所有偶数之间原始相对次序不变。
> 我们想象一下快排的荷兰国旗问题流程1.0版本，是将 <=x的数放左边，>x的数放右边，都是有个界定标准，满足放左边，不满足放右边，和这个题一样。假如这个题能做到稳定，那么荷兰国旗问题也能做到稳定了。设计快排的算法专家会不知道将快排设计成稳定的吗？
所以这是不可能做到的，所以这是一个坑。

2. 时间复杂度做到O(N)，额外空间复杂度做到O(1)。
> 

## 5. 工程上的改进
主要有两个方面：
1. 稳定性的考虑。
2. 充分利用O(N*logN)算法和O(N^2)算法的各自优势。



