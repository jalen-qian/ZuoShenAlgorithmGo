# 链表相关方法论
对于笔试，不用太在乎空间复杂度，一切为了时间复杂度，能使用容器方式就使用。<br>
对于面试，时间复杂度依然放第一位，但是要尽量找到空间复杂度更优的方法。

# 链表相关的技巧
1. 使用快慢指针
2. 使用容器（哈希表、栈、数组等）

# 快慢指针相关题
快慢指针的中心思想是准备两个指针，一个快指针，一个慢指针。比如要找中间节点，我们让每次快指针跳两个节点，慢指针跳1个节点，当快指针到尾部时，慢指针就在差不多中点的位置。下面有4个题：
1. 输入链表头节点，奇数长度返回中点，偶数长度返回上中点
2. 输入链表头节点，奇数长度返回中点，偶数长度返回下中点
3. 输入链表头节点，奇数长度返回中点前一个，偶数长度返回上中点前一个
4. 输入链表头节点，奇数长度返回中点前一个，偶数长度返回下中点前一个

代码详见[code01_linked_list_mid.go](code01_linked_list_mid.go)
对数器测试[code01_linked_list_mid_test.go](code01_linked_list_mid_test.go)

可以参考这种问题是如何写对数器测试的，对Coding能力是个很大的提升。

# 常见面试题
## 1.判断是否是回文结构
给定一个单链表的头节点head，请判断该链表是否为回文结构。示例如下：
```
1. 1->2->3->2->1->null 是回文结构，正着和反着看输出是一致的
2. 10->20->30>10->20->null 不是回文结构
3. 1->20->5->20->1-> null 是回文结构，注意20是个整体来看，虽然转变成字符串1205201这个字符串不是回文，但本题意不是转成字符串看，而是把每个数字当做整体看。
4. null 空链表认为是回文结构
```

### 实现思路
容器的方式就不讲了，代码详见[IsPalindrome1](code02_is_palindrome_list.go#L8)，重点说下如何用非容器的方式解决：
1. 我们先找到链表的中点或者上中点（偶数个就找上中点）
2. 从中点往右的位置，将链表反转，这样我们就得到了两个链表
3. 遍历两个链表，并一一比对，如果对不上，则记录不是回文的结论，每个都对上，则记录是回文的结论
4. 最后将原始链表还原

### 代码实现
详见 [code02_is_palindrome_list.go](code02_is_palindrome_list.go)

## 2.单链表荷兰国旗
将单链表按照某个特定值划分成小于在左边，等于在中间，大于在右边的形式，并返回新的头部。示例如下：
```
示例1:
1->5->8->3->4->2->0->6->3->1->null  划分值为3
划分成：2->1->1->0->3->3->4->5->6->8->null
注意，小于区域和大于区域可以任意顺序
```

### 实现思路1，使用容器
使用一个数组，先在数组上做荷兰国旗问题，做完再将链表重新串起来返回
代码实现如下：

[code03_smaller_equal_bigger.go](code03_smaller_equal_bigger.go#L10)

### 实现思路2，不使用容器
使用6个指针，`sH,sT eH,eT bH,bT`分别表示小于区域，等于区域和大于区域的头节点和尾节点，不断遍历链表，并将遍历到的节点与原链表断连，根据当前遍历到的值的大小，分别挂到等于区域，小于区域和大于区域中。
遍历完后，再将小于区域尾指针连接等于区域头指针，等于区域尾指针连接大于区域头指针。

这是大体的思路，实际执行时需要考虑很多边界情况，比如小于区域不存在，或者等于区域不存在，或者大于区域不存在等等。

遍历到一个节点，并挂到相应区域的流程如下，以小于区域为例：
1. 如果`sH == nil`，说明当前小于区域没加入过节点，则sH和sT都指向这个节点。
2. 如果`sH != nil`，说明当前小于区域加入过其他节点了，则先将sT的Next指针指向当前节点（`sT.Next = cur`)，然后sT再指向当前节点（`sT=cur`)。

详细代码实现如下：

[code03_smaller_equal_bigger.go](code03_smaller_equal_bigger.go#L62)