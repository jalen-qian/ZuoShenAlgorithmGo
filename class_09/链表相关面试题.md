# 链表相关方法论
对于笔试，不用太在乎空间复杂度，一切为了时间复杂度，能使用容器方式就使用。<br>
对于面试，时间复杂度依然放第一位，但是要尽量找到空间复杂度更优的方法。

# 链表相关的技巧
1. 使用快慢指针
2. 使用容器（哈希表、栈、数组等）

# 快慢指针相关题
快慢指针的中心思想是准备两个指针，一个快指针，一个慢指针。比如要找中间节点，我们让每次快指针跳两个节点，慢指针跳1个节点，当快指针到尾部时，慢指针就在差不多中点的位置。下面有4个题：
1. 输入链表头节点，奇数长度返回中点，偶数长度返回上中点
2. 输入链表头节点，奇数长度返回中点，偶数长度返回下中点
3. 输入链表头节点，奇数长度返回中点前一个，偶数长度返回上中点前一个
4. 输入链表头节点，奇数长度返回中点前一个，偶数长度返回下中点前一个

代码详见[code01_linked_list_mid.go](code01_linked_list_mid.go)
对数器测试[code01_linked_list_mid_test.go](code01_linked_list_mid_test.go)

可以参考这种问题是如何写对数器测试的，对Coding能力是个很大的提升。

# 常见面试题
## 1.判断是否是回文结构
给定一个单链表的头节点head，请判断该链表是否为回文结构。示例如下：
```
1. 1->2->3->2->1->null 是回文结构，正着和反着看输出是一致的
2. 10->20->30>10->20->null 不是回文结构
3. 1->20->5->20->1-> null 是回文结构，注意20是个整体来看，虽然转变成字符串1205201这个字符串不是回文，但本题意不是转成字符串看，而是把每个数字当做整体看。
4. null 空链表认为是回文结构
```

### 实现思路
容器的方式就不讲了，代码详见[IsPalindrome1](code02_is_palindrome_list.go#L8)，重点说下如何用非容器的方式解决：
1. 我们先找到链表的中点或者上中点（偶数个就找上中点）
2. 从中点往右的位置，将链表反转，这样我们就得到了两个链表
3. 遍历两个链表，并一一比对，如果对不上，则记录不是回文的结论，每个都对上，则记录是回文的结论
4. 最后将原始链表还原

### 代码实现
详见 [code02_is_palindrome_list.go](code02_is_palindrome_list.go)

## 2.单链表荷兰国旗
将单链表按照某个特定值划分成小于在左边，等于在中间，大于在右边的形式，并返回新的头部。示例如下：
```
示例1:
1->5->8->3->4->2->0->6->3->1->null  划分值为3
划分成：2->1->1->0->3->3->4->5->6->8->null
注意，小于区域和大于区域可以任意顺序
```

### 实现思路1，使用容器
使用一个数组，先在数组上做荷兰国旗问题，做完再将链表重新串起来返回
代码实现如下：

[code03_smaller_equal_bigger.go](code03_smaller_equal_bigger.go#L10)

### 实现思路2，不使用容器
使用6个指针，`sH,sT eH,eT bH,bT`分别表示小于区域，等于区域和大于区域的头节点和尾节点，不断遍历链表，并将遍历到的节点与原链表断连，根据当前遍历到的值的大小，分别挂到等于区域，小于区域和大于区域中。
遍历完后，再将小于区域尾指针连接等于区域头指针，等于区域尾指针连接大于区域头指针。

这是大体的思路，实际执行时需要考虑很多边界情况，比如小于区域不存在，或者等于区域不存在，或者大于区域不存在等等。

遍历到一个节点，并挂到相应区域的流程如下，以小于区域为例：
1. 如果`sH == nil`，说明当前小于区域没加入过节点，则sH和sT都指向这个节点。
2. 如果`sH != nil`，说明当前小于区域加入过其他节点了，则先将sT的Next指针指向当前节点（`sT.Next = cur`)，然后sT再指向当前节点（`sT=cur`)。

详细代码实现如下：

[code03_smaller_equal_bigger.go](code03_smaller_equal_bigger.go#L62)

## 3.存在随机指针的单链表复制问题
一种特殊的单链表节点类描述如下
```go
type NodeWithRandom struct {
    Value int
    Next *Node
    Rand *Node
}
```
`Rand`指针是单链表节点结构中新增的指针，`Rand`可能指向链表中的任意一个节点，也可能指向null。

给定一个由NodeWithRandom节点类型组成的无环单链表的头节点 head，请实现一个函数完成这个链表的复制，并返回复制的新链表的头节点。

请注意复制后的单链表，Rand指针的指向也要与原始链表一一对应。

**要求**
时间复杂度O(N)，额外空间复杂度O(1) 

### 实现思路1 空间复杂度O(N)使用容器
1. 我们定义一个`map[*Node]*Node`，map的key是原始节点，map的value是新的节点，节点值与key的值相同。这样我们就建立了原始节点与新节点的一一对应关系。
2. 我们遍历原始链表，每遍历到一个节点`cur`，都从map中找到对应节点`cur'`，同时找到当前节点的Next和Rand对应的`Next'`和`Rand'`,并让`cur.Next`指向`Next'`,`cur.Rand`指向`Rand'`。

实现代码如下：

[code04_copy_list_with_random.go](code04_copy_list_with_random.go#L11)

### 实现思路2 不使用容器
实现方案有3个步骤：
1. 我们遍历原始链表，每遍历一个节点，就生成一个对应节点插入到当前节点的下一个。
2. 从头开始遍历，每次遍历隔开一个，保证只遍历原始节点，并调整伴随节点的Rand指针的指向。比如遍历到`cur`节点，则`cur`节点的伴随节点是`cur.Next`，我们称为`cur'`，那么`cur'`的Rand指针，就是`cur.Rand.Next`。
3. 每个节点的Rand指针都调整好之后，将伴随节点从原链表剥离，成为新的链表，原链表恢复。

举例如下：
```
比如有个链表 1->3->5->2，其中1的Rand指向5,3的Rand指向2，其他的Rand指向空
1. 遍历并插入对应的节点到每个节点的下一个，如下：
   1->1'->3->3'->5->5'->2->2'
2. 从1开始遍历，每次遍历跳1步，跳过伴随节点，则会分别遍历到1，3，5，2
   a. 遍历到1，找到1的Rand指向了5，5的Next找到了5'，则将1'的Rand指向5'
   b. 遍历到3，找到3的Rand指向了2，2的Next找到了2'，则将3'的Rand指向2'
   c. 遍历到5，Rand为空，不处理。
   d. 遍历到2，Rand为空，不处理。
3. 将伴随的节点从原链表剥离，变成：
   1->3->5->2
   1'->3'->5'->2'
4. 返回1'的指针。
```

实现代码如下：

[code04_copy_list_with_random.go](code04_copy_list_with_random.go#L29)

## 4. 获取两个链表第一个相交的节点
给定两个可能有环也可能无环的单链表，头节点head1和head2。请实现一个函数，如果两个链表相交，请返回相交的 第一个节点。如果不相交，返回null

**要求**:<br>
如果两个链表长度之和为N，时间复杂度请达到O(N)，额外空间复杂度 请达到O(1)。 

### 思路
由于两个单链表都是既可能有环，又可能无环，我们先做第一件事：获取两个链表各自是否有环，如果有环，返回第一个入环的节点（用loop1和loop2表示），如果没环，则返回null。

比如：`1->2->3->4->5->(2)`，5指向之前的2，不好画图，用括号表示。那么第一个入环节点就是2。<br>
再比如：`1->2->3->4->5->(1)`，尾节点正好指向头节点，虽然整体都是环内的节点，但是头节点是1，所以第一个入环节点是1。<br>

**如何找到第一个入环节点？快慢指针**<br>
我们准备两个指针`fast`和`slow`，`fast`每次走两步，`slow`每次走1步。
1. 如果快指针走到空了，停止，这个链表一定不是有环的链表，返回null。
2. 如果是有环的，快指针会重新回到慢指针前面，并在某个节点处与慢指针相遇。
3. 当快慢指针相遇时，让快指针重新指向头部，慢指针留在相遇的节点，**快指针和慢指针都一次走1步**，下次快指针和慢指针相遇的节点，就是第一个入环节点。

我们举个例子：
```
1->2->3->4->5->6->7->(3)  3节点是第一个入环节点
a. fast和slow初始都指向1，fast每次走2步，slow1步，那么会在6的位置第一次相遇。
b. slow留在6，fast回到1位置，都每次走一步，会发现，fast和slow都走两步后，在3位置相遇了，3位置是第一个入环节点。
```

**分类讨论**

我们找到了两个链表是否有环，以及第一个入环节点。那么可以分类讨论：
1. 如果head1和head2都是无环的，那么分别遍历head1和head2到尾节点，算出两个链表的长度，然后较长的先跳过长度差个节点，然后一起往下走，第一个相遇的节点，就是全局的答案（第一个相交节点），如果遍历到尾都没有遇到，则不相交，返回null。
2. 如果head1和head2有一个有环，有一个无环，**那么一定不可能有相交的节点**，直接返回null。
3. 如果head1和head2都是有环的，那么分情况讨论:
   - 3.1 如果两个入环节点相同，那么一定是共用了一个环，并且相交的点在环之前，我们如果从入环节点处断开，就成了1的情况，用1的方式找到第一个相交节点返回。
   - 3.2 如果两个入环节点不相同，那么要么不相交，要么相交点就是两个入环节点其中的一个。我们只需要让其中一个绕环一圈，如果能与第二个相遇，就返回loop1，否则说明不相交，返回null。

举例说明：
```
1情况，两个无环链表： 
    例如 head1 是 1->2->3->4->5->6->7->8
    并且 head2 是 9->(5)->(6)->(7)->(8)
    其中 5 6 7 8 都是相交的节点，我们需要找到5节点。
    我们先遍历，head1的长度是8，head2的长度是5，说明相差3，且head1较长。
    我们让head1先跳3步，来到4的位置，然后两个链表一起跳，跳1步就会在5相遇，返回5。

3.1情况，两个有环，但loop1==loop2：
    例如 head1 1->2->3->4->5->6->7->(4)  loop1是4
    并且 head2 9->8->(3)->4->5->6->7->(4)  loop2也是同一个4，但是相交的点在3（入环前）
    由于loop1==loop2，说明是共用了一整个环，那么相交点必定在入环前。
    我们将head1和head2都在遍历到(4)时停止，不往后遍历，则成了1情况
    head1是 1->2->3->4   head2是 9->8-(3)->(4) 在3相交，用情况1的方法能找到3，并返回。
 
 3.2情况，两个有环，但loop1!=loop2： 
     例如 head1 1->2->3->4->5->6->7->8->(3) 在3入环， loop1 == 3
     并且 head2  9->8->(6)->7->8->3->4->5->(6) 在6入环，loop2 == 6
     入环的节点分别是环 3->4->5->6->7->8->(3) 中的3和6。
     我们让cur = loop1.next ，然后绕着环走，一定会遇到loop2也就是(6)，此时说明是相交的，返回loop1和loop2都行。
     如果饶了一圈，都没遇到loop2，说明是两个独立的有环链表，返回null。
```
### 代码实现
[code04_copy_list_with_random_test.go](code04_copy_list_with_random_test.go)