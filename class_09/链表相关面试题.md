# 链表相关方法论
对于笔试，不用太在乎空间复杂度，一切为了时间复杂度，能使用容器方式就使用。<br>
对于面试，时间复杂度依然放第一位，但是要尽量找到空间复杂度更优的方法。

# 链表相关的技巧
1. 使用快慢指针
2. 使用容器（哈希表、栈、数组等）

# 快慢指针相关题
快慢指针的中心思想是准备两个指针，一个快指针，一个慢指针。比如要找中间节点，我们让每次快指针跳两个节点，慢指针跳1个节点，当快指针到尾部时，慢指针就在差不多中点的位置。下面有4个题：
1. 输入链表头节点，奇数长度返回中点，偶数长度返回上中点
2. 输入链表头节点，奇数长度返回中点，偶数长度返回下中点
3. 输入链表头节点，奇数长度返回中点前一个，偶数长度返回上中点前一个
4. 输入链表头节点，奇数长度返回中点前一个，偶数长度返回下中点前一个

代码详见[code01_linked_list_mid.go](code01_linked_list_mid.go)
对数器测试[code01_linked_list_mid_test.go](code01_linked_list_mid_test.go)

可以参考这种问题是如何写对数器测试的，对Coding能力是个很大的提升。

# 常见面试题
## 1.判断是否是回文结构
给定一个单链表的头节点head，请判断该链表是否为回文结构。示例如下：
```
1. 1->2->3->2->1->null 是回文结构，正着和反着看输出是一致的
2. 10->20->30>10->20->null 不是回文结构
3. 1->20->5->20->1-> null 是回文结构，注意20是个整体来看，虽然转变成字符串1205201这个字符串不是回文，但本题意不是转成字符串看，而是把每个数字当做整体看。
4. null 空链表认为是回文结构
```

### 实现思路
容器的方式就不讲了，代码详见[IsPalindrome1](code02_is_palindrome_list.go#L8)，重点说下如何用非容器的方式解决：
1. 我们先找到链表的中点或者上中点（偶数个就找上中点）
2. 从中点往右的位置，将链表反转，这样我们就得到了两个链表
3. 遍历两个链表，并一一比对，如果对不上，则记录不是回文的结论，每个都对上，则记录是回文的结论
4. 最后将原始链表还原

### 代码实现
详见 [code02_is_palindrome_list.go](code02_is_palindrome_list.go)

## 2.单链表荷兰国旗
将单链表按照某个特定值划分成小于在左边，等于在中间，大于在右边的形式，并返回新的头部。示例如下：
```
示例1:
1->5->8->3->4->2->0->6->3->1->null  划分值为3
划分成：2->1->1->0->3->3->4->5->6->8->null
注意，小于区域和大于区域可以任意顺序
```

### 实现思路1，使用容器
使用一个数组，先在数组上做荷兰国旗问题，做完再将链表重新串起来返回
代码实现如下：

[code03_smaller_equal_bigger.go](code03_smaller_equal_bigger.go#L10)

### 实现思路2，不使用容器
使用6个指针，`sH,sT eH,eT bH,bT`分别表示小于区域，等于区域和大于区域的头节点和尾节点，不断遍历链表，并将遍历到的节点与原链表断连，根据当前遍历到的值的大小，分别挂到等于区域，小于区域和大于区域中。
遍历完后，再将小于区域尾指针连接等于区域头指针，等于区域尾指针连接大于区域头指针。

这是大体的思路，实际执行时需要考虑很多边界情况，比如小于区域不存在，或者等于区域不存在，或者大于区域不存在等等。

遍历到一个节点，并挂到相应区域的流程如下，以小于区域为例：
1. 如果`sH == nil`，说明当前小于区域没加入过节点，则sH和sT都指向这个节点。
2. 如果`sH != nil`，说明当前小于区域加入过其他节点了，则先将sT的Next指针指向当前节点（`sT.Next = cur`)，然后sT再指向当前节点（`sT=cur`)。

详细代码实现如下：

[code03_smaller_equal_bigger.go](code03_smaller_equal_bigger.go#L62)

## 1.存在随机指针的单链表复制问题
一种特殊的单链表节点类描述如下
```go
type NodeWithRandom struct {
    Value int
    Next *Node
    Rand *Node
}
```
`Rand`指针是单链表节点结构中新增的指针，`Rand`可能指向链表中的任意一个节点，也可能指向null。

给定一个由NodeWithRandom节点类型组成的无环单链表的头节点 head，请实现一个函数完成这个链表的复制，并返回复制的新链表的头节点。

请注意复制后的单链表，Rand指针的指向也要与原始链表一一对应。

**要求**
时间复杂度O(N)，额外空间复杂度O(1) 

### 实现思路1 空间复杂度O(N)使用容器
1. 我们定义一个`map[*Node]*Node`，map的key是原始节点，map的value是新的节点，节点值与key的值相同。这样我们就建立了原始节点与新节点的一一对应关系。
2. 我们遍历原始链表，每遍历到一个节点`cur`，都从map中找到对应节点`cur'`，同时找到当前节点的Next和Rand对应的`Next'`和`Rand'`,并让`cur.Next`指向`Next'`,`cur.Rand`指向`Rand'`。

实现代码如下：

[code04_copy_list_with_random.go](code04_copy_list_with_random.go#L11)

### 实现思路2 不使用容器
实现方案有3个步骤：
1. 我们遍历原始链表，每遍历一个节点，就生成一个对应节点插入到当前节点的下一个。
2. 从头开始遍历，每次遍历隔开一个，保证只遍历原始节点，并调整伴随节点的Rand指针的指向。比如遍历到`cur`节点，则`cur`节点的伴随节点是`cur.Next`，我们称为`cur'`，那么`cur'`的Rand指针，就是`cur.Rand.Next`。
3. 每个节点的Rand指针都调整好之后，将伴随节点从原链表剥离，成为新的链表，原链表恢复。

举例如下：
```
比如有个链表 1->3->5->2，其中1的Rand指向5,3的Rand指向2，其他的Rand指向空
1. 遍历并插入对应的节点到每个节点的下一个，如下：
   1->1'->3->3'->5->5'->2->2'
2. 从1开始遍历，每次遍历跳1步，跳过伴随节点，则会分别遍历到1，3，5，2
   a. 遍历到1，找到1的Rand指向了5，5的Next找到了5'，则将1'的Rand指向5'
   b. 遍历到3，找到3的Rand指向了2，2的Next找到了2'，则将3'的Rand指向2'
   c. 遍历到5，Rand为空，不处理。
   d. 遍历到2，Rand为空，不处理。
3. 将伴随的节点从原链表剥离，变成：
   1->3->5->2
   1'->3'->5'->2'
4. 返回1'的指针。
```

实现代码如下：

[code04_copy_list_with_random.go](code04_copy_list_with_random.go#L29)

