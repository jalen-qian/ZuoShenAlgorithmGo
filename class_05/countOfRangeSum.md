# 区间和的个数问题

---
## 1.区间和的个数问题介绍
给你一个整数数组`nums` 以及两个整数`lower` 和 `upper` 。求数组中，值位于范围 `[lower, upper]` （包含`lower`和`upper`）之内的区间和的个数 。

区间和`S(i, j)`表示在`nums`中，位置从`i`到`j`的元素之和，包含`i`和`j`(i ≤ j)。

示例 1：
```
输入：nums = [-2,5,-1], lower = -2, upper = 2
输出：3
解释：存在三个区间：[0,0]、[2,2] 和 [0,2] ，对应的区间和分别是：-2 、-1 、2 。
```
示例 2：
```
输入：nums = [0], lower = 0, upper = 0
输出：1
```
提示：
- 1 <= nums.length <= 105
- 231 <= nums[i] <= 231 - 1
- 105 <= lower <= upper <= 105
- 题目数据保证答案是一个 32 位 的整数

# 2.实现思路
## 2.1 暴力方式
如果使用暴力的方式解决这个问题，我们可以遍历每个区间，求区间和，并判断区间和是否在`[lower, upper]`范围内。
遍历每个区间，是个O(N^2)的过程，求区间和是O(N)的复杂度，整体复杂度是O(N^3)，具体解析如下：

0~N-1范围内的区间个数是个等差数列，遍历的范围分别为：
```
0~0 0~1 0~2 0~3 ... 0~N-1
    1~1 1~2 1~3 ... 1~N-1
...
                    N-1 ~ N-1
```
遍历区间的次数是个等差数列（O(N^2)的算法），而求每个区间和的过程，是将这个区间遍历一遍累加，时间复杂度为O(N)，所以整个流程的时间复杂度为O(N^3)

## 2.1 使用归并排序
同样使用归并排序也能解决这个问题，并能将时间复杂度优化到O(N * logN)，但是需要知道几个前置的知识。

## 2.1 前置知识1：使用**前缀和**计算区间和大小

`i`位置前缀和的概念是，数组`nums`在`[0~i]`区间的区间和（前缀和也是区间和，只不过一定是从0开始的）。
那么有以下结论：
> nums 数组在`i`到`j`之间的区间和，等于nums在 0~j 的区间和 减去 0~i-1的区间和

也就是说，**区间和可以通过前缀和相减计算出来**

那么，我们生成一个前缀和数组`sum`, `sum[i]` 表示数组 `nums` 在0~i范围的区间和。（生成这个数组的过程只需要遍历一遍`nums`，时间复杂度O(N)）<br>
当我们求`i~j`范围的区间和时，就可以直接用 `sum[j] - sum[i]` 来求。

## 2.2 前置知识2：通过前缀和数组求区间和个数
我们先生成一个前缀和数组 `sum`:<br>
对于任意位置`i`和`j`（i<=j），假设已知 `sum[j] = x`, 那么`sum[j]-sum[i]` 如果达标（达标指的是在 lower到upper范围），说明`sum[i] 必定在 [x-upper, x-lower]`区间。

那么反过来说：**对于`sum[j]`来说，在sum数组j位置前面的任意一个位置i，如果 sum[i] 在 `[x-upper, x-lower]`范围内，则必定有`sum[j]-sum[i]`在
`[lower,upper]`范围**，而`sum[j]-sum[i]`就是原始数组在[i,j]范围的区间和，则说明原始数组区间`i~j`是达标的。

所以我们求出`sum`数组每个位置左边有多少个数在`[x-upper, x-lower]`范围内，并统计个数，就求出了整个`nums`数组区间和在`[lower,upper]`范围的区间的个数，答案就出来了。

## 2.3 使用归并排序求解

经过上面的两个前置知识，我们成功把区间和问题，**转换成了统计一个数组的每个数，左边有多少个数在某个范围内的问题**。而这正是归并排序能够处理的问题。（归并排序思想和流程参考前面的文章）
而统计这个个数，可以放在归并排序的merge过程中，归并排序要做到O(N*logN)，`merge`过程必须是O(N)的。

merge过程是左右两个有序数组，最终合并成一个有序数组的过程，不熟悉的看前面归并排序的介绍。以下`左边数组``右边数组`指的就是merge过程的左右两个有序数组。

在这个题目中，归并排序的`merge`过程需要做两件事：
1. 遍历左右数组，求出每个又组的数x，在左组数中有多少个数在x的限定范围（也就是达标的子区间个数），并统计
2. 执行普通的merge过程，让左右数组变成整体有序。

### 2.3.1 如何做到merge过程O(N)

所以我们**统计右边数组的每个数，左边数组有多少个数在[x-upper, x-lower]范围内**这个过程也必须是O(N)的。如果我们直接遍历去求，那么肯定时间复杂度是O(N^2)了，因为遍历每次循环后会下标回退，那么怎么做到O(N)呢？

我们发现，对于右边数组的每个数x，越是右边的数，其控制区间[x-upper, x-lower]也是两个边界也是往右平移的。所以我们可以用一个滑动窗口来处理，让左边的下标不会回退。具体过程如下：

1. 我们规定两个下标`L`和`R`，初始时都处在左数组的第一个位置。
2. 遍历右边的数，将`L`往右滑动到第一个 `>= x-upper`的位置，将R往右滑动到最后一个 `< x-lower`的位置。
3. 此时右边的数x，在左边数组中满足条件的数的个数就是 R - L。
4. 继续遍历，重复3的过程，直到右边的数遍历完。


### 2.3.2 举例说明
下面举个`merge`过程的具体的例子：

假设我们左右两个数组分别是`[2 5 8 9 11 15]`和`[6 7 7 8 10 11]`，给定范围是`[-1, 2]`
```

1. L和R都指向左数组0位置，又组下标I指向6
    [2 5 8 9 11 15]  [6 7 7 8 10 11]
     L                I 
     R 
此时6的有效范围是[4,7]，L滑到第一个>=4的位置，R滑到第一个>7的位置，即：
    [2 5 8 9 11 15]  [6 7 7 8 10 11]
       L R            I
此时6的有效范围内有 R-L = 1个

2. 然后I跳到7,7的范围是[5,8], L和R分别滑动到下面>=5的第一个位置和>8的第一个位置
    [2 5 8 9 11 15]  [6 7 7 8 10 11]
       L   R            I
此时7的有效范围内有 R-L = 2个

3. 然后I跳到下个7，窗口不变，再加2个

4. 然后I跳到8,8的范围是[6,9]，L和R分别滑动到 >= 6的第一个位置和 >9 的第一个位置，即
    [2 5 8 9 11 15]  [6 7 7 8 10 11]
       L     R              I
此时7的有效范围内有 R-L = 3个

4. 然后I跳到10位置，10的范围是[8,11]，L和R分别滑动到第一个>=8的位置和第一个>11的位置，即
    [2 5 8 9 11 15]  [6 7 7 8 10 11]
         L       R            I
此时10的有效范围内有3个

4. 然后I跳到11位置，11的范围是[9,12]，L和R分别滑动到第一个>=9的位置和第一个>12的位置，即
    [2 5 8 9 11 15]  [6 7 7 8 10 11]
             L   R               I
此时11的有效范围内有1个
综上：一共统计到了1+2+2+3+3+1=12个区间的区间和在[-1,2]范围。
```

## 2.具体代码

