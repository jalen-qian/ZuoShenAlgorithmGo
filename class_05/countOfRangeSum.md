# 区间和的个数问题

---
## 1.区间和的个数问题介绍
给你一个整数数组`nums` 以及两个整数`lower` 和 `upper` 。求数组中，值位于范围 `[lower, upper]` （包含`lower`和`upper`）之内的区间和的个数 。

区间和`S(i, j)`表示在`nums`中，位置从`i`到`j`的元素之和，包含`i`和`j`(i ≤ j)。

示例 1：
```
输入：nums = [-2,5,-1], lower = -2, upper = 2
输出：3
解释：存在三个区间：[0,0]、[2,2] 和 [0,2] ，对应的区间和分别是：-2 、-1 、2 。
```
示例 2：
```
输入：nums = [0], lower = 0, upper = 0
输出：1
```
提示：
- 1 <= nums.length <= 105
- 231 <= nums[i] <= 231 - 1
- 105 <= lower <= upper <= 105
- 题目数据保证答案是一个 32 位 的整数

# 2.实现思路
## 2.1 暴力方式
如果使用暴力的方式解决这个问题，我们可以遍历每个区间，求区间和，并判断区间和是否在`[lower, upper]`范围内。
遍历每个区间，是个O(N^2)的过程，求区间和是O(N)的复杂度，整体复杂度是O(N^3)，具体解析如下：

0~N-1范围内的区间个数是个等差数列，遍历的范围分别为：
```
0~0 0~1 0~2 0~3 ... 0~N-1
    1~1 1~2 1~3 ... 1~N-1
...
                    N-1 ~ N-1
```
遍历区间的次数是个等差数列（O(N^2)的算法），而求每个区间和的过程，是将这个区间遍历一遍累加，时间复杂度为O(N)，所以整个流程的时间复杂度为O(N^3)

## 2.1 使用归并排序
同样使用归并排序也能解决这个问题，并能将时间复杂度优化到O(N * logN)，但是需要知道几个前置的知识。

## 2.1 前置知识1：使用**前缀和**计算区间和大小

`i`位置前缀和的概念是，数组`nums`在`[0~i]`区间的区间和（前缀和也是区间和，只不过一定是从0开始的）。
那么有以下结论：
> nums 数组在`i`到`j`之间的区间和，等于nums在 0~j 的区间和 减去 0~i-1的区间和

也就是说，**区间和可以通过前缀和相减计算出来**

那么，我们生成一个前缀和数组`sum`, `sum[i]` 表示数组 `nums` 在0~i范围的区间和。（生成这个数组的过程只需要遍历一遍`nums`，时间复杂度O(N)）<br>
当我们求`i~j`范围的区间和时，就可以直接用 `sum[j] - sum[i]` 来求。

## 2.2 前置知识2：通过前缀和数组求区间和个数
我们先生成一个前缀和数组 `sum`:<br>
对于任意位置`i`和`j`（i<=j），假设已知 `sum[j] = x`, 那么`sum[j]-sum[i]` 如果达标（达标指的是在 lower到upper范围），说明`sum[i] 必定在 [x-upper, x-lower]`区间。

那么反过来说：**对于`sum[j]`来说，在sum数组j位置前面的任意一个位置i，如果 sum[i] 在 `[x-upper, x-lower]`范围内，则必定有`sum[j]-sum[i]`在
`[lower,upper]`范围**，而`sum[j]-sum[i]`就是原始数组在[i,j]范围的区间和，则说明原始数组区间`i~j`是达标的。

所以我们求出`sum`数组每个位置左边有多少个数在`[x-upper, x-lower]`范围内，并统计个数，就求出了整个`nums`数组区间和在`[lower,upper]`范围的区间的个数，答案就出来了。

## 2.3 使用归并排序求解
经过上面的两个前置知识，我们成功把区间和问题，**转换成了统计一个数组的每个数，左边有多少个数在某个范围内的问题**。而这正是归并排序能够处理的问题。（归并排序思想和流程参考前面的文章。）

算法具体过程如下：
1. 生成一个前缀和数组`sum`
2. 对sum数组执行归并排序，并在`merge`过程中统计达标的个数，执行两个流程，**先统计达标的左组数个数，再merge**。

举个例子如下：

左组和又组分别为`[2 4 5 7]` 和 `[3 6 8 9]`，lower和upper为`-2`和`3`，
<br>对于又组数3而言，左边的数如果在`3-3=0 ~ 3-(-2) = 5 [0,5]范围内则达标。
<br>同理，6的范围为[3,8]，8的范围为[5,10]，9的范围为[6,11]
1. 我们先pk左右组数，只统计不拷贝，
 - 2 和 3 PK，2在[0,5]范围，满足，count++
 - 4 和 3 pk, 4在[0,5]范围，满足，count++
 - 5 和 3 pk, 5在[0,5]范围，满足，count++
 - 7 和 3 pk, 7不在[0,5]，不统计
 - 2 和 6 pk, 2不在[3,8]，不统计
 - 4 和 6 pk, 4在[3,8]范围，满足，count++
 - 5 和 6 pk, 5在[3,8]范围，满足，count++
 - 7 和 6 pk, 7在[3,8]范围，满足，count++
 - 2 和 8 pk, 2不在[5,10]，不统计
 - 4 和 8 pk, 4不在[5,10]，不统计
 - 5 和 8 pk, 5在[5,10]范围，满足，count++
 - 7 和 8 pk, 7在[5,10]范围，满足，count++
 - 2 和 9 pk, 2不在[6,11]，不统计
 - 4 和 9 pk, 4不在[6,11]，不统计
 - 5 和 9 pk, 5不在[6,11]，不统计
 - 7 和 9 pk, 7在[6,11]范围，满足，count++

整体看，在这个流程中，一共有9个满足条件的子区间。时间复杂度是O(N)




然后再对`[2 4 5 7]` 和 `[3 6 8 9]`进行一次普通的merge过程，让数组排好序。

