# 归并排序
归并排序是一种时间复杂度为 `O(N*logN)`的排序算法，利用的是递归的思想。

## 1.实现思路
假设我们有个数组`arr`，并且我们实现了一个函数`process(arr,L,R)`，这个`process`函数的功能是将数组从`L`位置到`R`位置
变成有序的。

比如有个数组是`[8 2 1 9 7 5]`，如果我们输入`process(arr,1,4)`，那么`process`函数将会使得`arr`数组变为：
```
[8 1 2 7 9 5] // 在 1 到 4位置上排好序
```

我们有了这个`process`函数后，就能利用二分和递归思想了。<br>

1. 将数组二分，找到中间位置`M`,那么数组分为`0~M`和`M+1~N-1`两个部分。
2. 调用 `process(arr, 0, M)`，让数组的左半部分有序
3. 调用 `process(arr, M+1, N-1)`，让数组的右半部分有序
4. 调用一个`merge`函数，这个`merge`函数将两个有序数组合并成整体有序的数组
> 在执行完这4个步骤后，arr数组就整体排好序了。

由于`process`函数只是数据规模变成了原来的一半，所以process内部可以**继续二分后递归调用自己**

接下来说下merge函数的过程，这是一个O(N)复杂度的过程：

我们得到了两个已经排好序的子数组`arr1`和`arr2`
1. 我们先分配一个空数组`help`，这个空数组长度是两个数组长度之和
2. 准备两个索引分别指向两个数组的0位置，并不断比较两个位置的数，谁小则将对应的数拷贝到空数组中，并将索引往下进一位
3. 如果有一个数组越界了，则停止，并将剩余的数直接拷贝到`help`中。
4. 最后将`help`中的数回填到arr1和arr2中（arr1和arr2是大数组的左半部分和右半部分，回填后整个数组就有序了）

我们举个例子，假如大数组是 `arr[3 8 4 6]`，则arr1是`[3 8]` arr2是`[4 6]`
1. 准备数组长度是4`help[0 0 0 0]`, 两个索引分别是`index1=0,index2=2`(指向两个子数组的0位置)
2. 比较3<4，则将3拷贝到help中，并将index1++，`help[3 0 0 0], index1=1 index2=2`
3. 比较8>4，则将4拷贝到help中，并将index2++，`help[3 4 0 0], index1=1 index2=3`
4. 比较8>6，则将6拷贝到help中，并将index2++，`help[3 4 6 0], index1=1 index2=4`
5. 此时index2==4已经越界，所以将arr1中剩下的8写入数组help，`help[3 4 6 8]`
6. 将help的数依次写入到arr中，此时arr数组整体排好了序。

我们分析merge函数的时间复杂度，整个流程只是索引依次递增，最后将help写回arr的过程也是只进行了N次赋值操作
所以整体的时间复杂度为O(N)

## 2.分析整个归并排序流程的时间复杂度
利用递归的**Master公式**，我们将数据量分成了两个相等的部分，在执行完`process`后，执行了一个时间复杂度为`O(N)`的`merge`函数。
所以Master公式为：
```
T(N) = a * T(N/b) + O(N^d)
我们的算法中，
T(N) = 2 * (1/2 N ) + O(N)
a = 2
b = 2
d = 1，由此可知：
d = logb a(b为底a的对数） log 2 2 为1，d也等于1
```
所以**整体的时间复杂度是O(N * logN)**


## 代码实现
代码实现见[code01_merge_sort.go](code01_merge_sort.go)

## 关于递归
所有的递归流程，都可以被实现成非递归的流程，因为递归本质是用系统栈实现的，最终底层的流程仍然是非递归的。
如果我们自己实现这个栈，就能用非递归的代码实现递归代码的逻辑。

## 如何用非递归的方式实现mergeSort
实现思路：我们设计一个变量叫“步长”（step），将数组按照步长分组，开始的时候步长是1，则每相邻的两个数为一组。<br>
我们将每一组数都进行一次`merge`动作，进行完后让index跳过step的长度来到下一组，让每组数变成有序的，然后“步长”变成2，重复上面的步骤。
下一次步长变成4，继续重复，直到步长超过整体数组的长度，就停止。

举个栗子，假设我们有个数组`arr[6 3 8 2 9 7 1]`
> 1. step == 1，分为4组，每组分别是`6 3` `8 2` `9 7` `1`，都进行merge之后，变成了`arr[3 6 2 8 7 9 1]`
> 2. step == 2, 分为2组，分别是`3 6 与 2 8` 以及 `7 9 与 1`，都进行merge之后，变成了`arr[2 3 6 8 1 7 9]`
> 3. step == 4，只能分1组，为`2 3 6 8 和 1 7 9`,merge之后，arr就整体有序了`arr[1 2 3 6 7 8 9 ]` 
> 4. step == 8，超过了数组长度7，停止。

我们发现，每次step都会比上一次增长1倍，也就是说，**调整步长一共进行了`logN`次**，然后每次merge动作是`O(N)`的，所以整体的时间复杂度是`O(N * logN)`

这个程序流程本质与递归的实现流程是一样的，所以不用`Master公式`我们也证明了**mergeSort的时间复杂度是O(N * logN)**

另外，

相关代码实现见[code02_merge_sort_iter.go](code02_merge_sort_iter.go)