# 归并排序
归并排序是一种时间复杂度为 `O(N*logN)`的排序算法，利用的是递归的思想。

## 1.实现思路
假设我们有个数组`arr`，并且我们实现了一个函数`process(arr,L,R)`，这个`process`函数的功能是将数组从`L`位置到`R`位置
变成有序的。

比如有个数组是`[8 2 1 9 7 5]`，如果我们输入`process(arr,1,4)`，那么`process`函数将会使得`arr`数组变为：
```
[8 1 2 7 9 5] // 在 1 到 4位置上排好序
```

我们有了这个`process`函数后，就能利用二分和递归思想了。<br>

1. 将数组二分，找到中间位置`M`,那么数组分为`0~M`和`M+1~N-1`两个部分。
2. 调用 `process(arr, 0, M)`，让数组的左半部分有序
3. 调用 `process(arr, M+1, N-1)`，让数组的右半部分有序
4. 调用一个`merge`函数，这个`merge`函数将两个有序数组合并成整体有序的数组
> 在执行完这4个步骤后，arr数组就整体排好序了。

由于`process`函数只是数据规模变成了原来的一半，所以process内部可以**继续二分后递归调用自己**

接下来说下merge函数的过程，这是一个O(N)复杂度的过程：

我们得到了两个已经排好序的子数组`arr1`和`arr2`
1. 我们先分配一个空数组`help`，这个空数组长度是两个数组长度之和
2. 准备两个索引分别指向两个数组的0位置，并不断比较两个位置的数，谁小则将对应的数拷贝到空数组中，并将索引往下进一位
3. 如果有一个数组越界了，则停止，并将剩余的数直接拷贝到`help`中。
4. 最后将`help`中的数回填到arr1和arr2中（arr1和arr2是大数组的左半部分和右半部分，回填后整个数组就有序了）

我们举个例子，假如大数组是 `arr[3 8 4 6]`，则arr1是`[3 8]` arr2是`[4 6]`
1. 准备数组长度是4`help[0 0 0 0]`, 两个索引分别是`index1=0,index2=2`(指向两个子数组的0位置)
2. 比较3<4，则将3拷贝到help中，并将index1++，`help[3 0 0 0], index1=1 index2=2`
3. 比较8>4，则将4拷贝到help中，并将index2++，`help[3 4 0 0], index1=1 index2=3`
4. 比较8>6，则将6拷贝到help中，并将index2++，`help[3 4 6 0], index1=1 index2=4`
5. 此时index2==4已经越界，所以将arr1中剩下的8写入数组help，`help[3 4 6 8]`
6. 将help的数依次写入到arr中，此时arr数组整体排好了序。

我们分析merge函数的时间复杂度，整个流程只是索引依次递增，最后将help写回arr的过程也是只进行了N次赋值操作
所以整体的时间复杂度为O(N)

## 2.分析整个归并排序流程的时间复杂度
利用递归的**Master公式**，我们将数据量分成了两个相等的部分，在执行完`process`后，执行了一个时间复杂度为`O(N)`的`merge`函数。
所以Master公式为：
```
T(N) = a * T(N/b) + O(N^d)
我们的算法中，
T(N) = 2 * (1/2 N ) + O(N)
a = 2
b = 2
d = 1，由此可知：
d = logb a(b为底a的对数） log 2 2 为1，d也等于1
```
所以**整体的时间复杂度是O(N * logN)**


## 代码实现
代码实现见`merge_sort.go` 

## 关于递归
所有的递归流程，都可以被实现成非递归的流程，因为递归本质是用系统栈实现的，最终底层的流程仍然是非递归的。
如果我们自己实现这个栈，就能用非递归的代码实现递归代码的逻辑。