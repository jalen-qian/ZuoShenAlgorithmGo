# 逆序对问题

---
## 1. 逆序对问题介绍
在一个数组中， 任何一个前面的数`a`，和任何一个后面的数`b`， 如果`(a,b)`是降序的，就称为逆序对。返回数组中所有的逆序对的个数。

举个简单的例子：
> 现在给定数组`arr[5 8 3 0 7]`，那么比如`a=1,b=3`时，是一个逆序对`(8,0)`，这个数组中有多少个逆序对呢？我们可以列举一下：
> - [0,1]为(5,8) 不是
> - [0,2]为(5,3) 是
> - [0,3]为(5,0) 是
> - [0,4]为(5,7) 不是
> - [1,2]为(8,3) 是
> - [1,3]为(8,0) 是
> - [1,4]为(8,7) 是
> - [2,3]为(3,0) 是
> - [2,4]为(3,7) 不是
> - [3,4]为(0,7) 不是
> 
> 则最终的逆序对个数是6个

## 2. 思路
我们发现上面的穷举法是个O(N^2)的算法。有没有更优的解法呢？当然是有的，我们还是可以利用归并排序（mergeSort）的过程。
逆序对问题可以转换为：对于数组中的每个数，找这个数的右边有多少个数比它小，并统计个数。这和[小和问题](smallSumProblem.md)其实是类似的。小和问题是找右边有多少个数比当前数大。

## 3. 实现思路
我们同样可以利用归并排序的流程，不同的是，我们从**最大的数开始PK**，在PK两个数组时，我们的指针都指向最右边。
1. 当左组数小于右组数时，拷贝右组数到help数组，不统计个数
2. 当左组数等于右组数时，拷贝右组数到help数组，不统计个数（不能拷贝左组，因为右组左边可能还有数比左组当前数小，拷贝左组会统计漏掉）
3. 当左组数大于右组数时，拷贝左组数，并将统计数**增加右组数剩余个数**

下面举一个简单的示例：
> 数组arr[0 2 7 8 3 4 6 8]，这个数组有多少个逆序对呢？我们数一下知道有6个（7和8各3个），怎么通过归并排序的过程统计呢？<br>
> 这个例子是为了不列举子过程，我们这个例子前4个数和后4个数已经设置成有序的了，也就是说这两个**子数组自身不会产生逆序对**。<br>
> 我们直接从最后一次合并来看（也就是[0 2 7 8] PK [3 4 6 8]：
> 1. 我们准备一个help数组，有8个长度 help[x x x x x x x x ] （x表示这个位置没有填值）
> 2. **我们从右往左PK**，开始状态 `count = 0`，`iL = 3, iR = 3` `iL`和`iR`分别是左右数组下标 
> 3. 8 PK 8，相等，拷贝右组的8，iR--，count不统计，逆序对个数为0，help=[x x x x x x x 8]
> 4. 8 PK 6, 左组大，拷贝左组的8，iL--，count+=3，逆序对个数是3 help=[x x x x x x 8 8]
> 5. 7 PK 6, 左组大，拷贝左组的7，iL--，count+=3，逆序对个数6 help=[x x x x x 7 8 8]
> 6. 2 PK 6，右组大，拷贝右组的6，iR--，count不统计，逆序对个数为6 help=[x x x x 6 7 8 8]
> 7. 2 PK 4，右组大，拷贝右组的4，iR--，count不统计，逆序对个数是6 help=[x x x 4 6 7 8 8]
> 8. 2 PK 3，右组大，拷贝右组的3，iR--，count不统计，逆序对个数是6 help=[x x 3 4 6 7 8 8]
> 9. 此时`iR==-1`已经越界，拷贝剩余左组的2 0，不产生逆序对，help=[0 2 3 4 6 7 8 8]
> 10. 最终整体的逆序对个数是6。
 
## 4. 代码实现

