# 堆
堆在很多语言中称为“优先级队列”，虽然名字有“队列”二字，但是底层实现实际上是一个堆。

堆是一个完全二叉树，且堆分为大根堆和小根堆。具体定义下面再讲。

# 完全二叉树
通俗解释：一个二叉树的上面的层一定是满的，不满的层是从左往右依次变满，那么这个二叉树是完全二叉树。

就是说，这个二叉树的任意节点，要么没有子树，在有子树时，不能**只有右子树没有左子树**，但可以只有左子树，无右子树。

比如下面的树是完全二叉树：
```
1. 空树是完全二叉树
2. 只有一个节点的数，也是完全二叉树
3. 下面的树前两层都是满的，最后一层不满，但是是在填满的过程中。
          2
        /   \
       5     8
      / \   /
     6   7  3
```

# 用数组实现一个完全二叉树
假设我们有个数组`arr`，和`size`变量。将它想象成一个完全二叉树的结构，**规定数组中的数的顺序，就是我们创建这个完全二叉树时添加数的顺序**。

从逻辑上可以把这个数组想象成一个完全二叉树。完全二叉树的添加顺序是从上到下，从左到右的。而`size`变量规定数组中前`size`个数在这个逻辑上的二叉树中，剩下的数都是无效的。

比如上面例子3中的完全二叉树，对应的数组是:
```
[2,5,8,6,7,3] size = 5
```
有了这个定义，我们很容易知道，对于数组中任意一个`i`位置的数：
1. 它的左孩子的位置是：`i * 2 + 1`
2. 它的右孩子的位置是：`i * 2 + 2`
3. 它的父亲的位置是：`(i-1) / 2`

# 堆
堆是一棵数组实现的完全二叉树，而且这个完全二叉树满足一个条件：
1. 对于大根堆，这棵树的所有子树，**其最大的数都在根节点**。
2. 对于小根堆，这棵树的所有子树，**其最小的数都在根节点**。

举例：
```
比如这是个大根堆：
          10
        /    \
       8      2
      / \    /
     6   7   1
1. 整棵树的最大值是10，在根节点
2. 左子树的最大值是8，在根节点
3. 右子树的最大值是2，在根节点
```
小根堆和大根堆是一样的，只不过最小的在根节点，这里就不多举例了。

## 大根堆实现逻辑
如何实现一个大根堆呢？当我们在一个堆中添加一个数后（一定在最后一层的最后一个叶子节点位置），将这个数与其父亲比较。
1. 如果比父亲小，或者与父亲相等，则不变。
2. 如果比父亲大，则与父亲交换，交换到父亲的位置后，继续与父亲比较，还是比父亲大，则继续交换。
3. 2过程一直进行到不比当前的父亲大，或者已经到0位置（整棵树的根节点），则停止。

## 代码实现
详细见：



