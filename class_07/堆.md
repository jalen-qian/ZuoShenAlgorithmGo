# 堆
堆在很多语言中称为“优先级队列”，虽然名字有“队列”二字，但是底层实现实际上是一个堆。

堆是一个完全二叉树，且堆分为大根堆和小根堆。具体定义下面再讲。

# 完全二叉树
通俗解释：一个二叉树的上面的层一定是满的，不满的层是从左往右依次变满，那么这个二叉树是完全二叉树。

就是说，这个二叉树的任意节点，要么没有子树，在有子树时，不能**只有右子树没有左子树**，但可以只有左子树，无右子树。

比如下面的树是完全二叉树：
```
1. 空树是完全二叉树
2. 只有一个节点的数，也是完全二叉树
3. 下面的树前两层都是满的，最后一层不满，但是是在填满的过程中，也是完全二叉树。
          2
        /   \
       5     8
      / \   /
     6   7  3
```

# 用数组实现一个完全二叉树
假设我们有个数组`arr`，和`size`变量。将它想象成一个完全二叉树的结构，**规定数组中的数的顺序，就是我们创建这个完全二叉树时添加数的顺序**。

从逻辑上可以把这个数组想象成一个完全二叉树。完全二叉树的添加顺序是从上到下，从左到右的。而`size`变量规定数组中前`size`个数在这个逻辑上的二叉树中，剩下的数都是无效的。

比如上面例子3中的完全二叉树，对应的数组是:
```
[2,5,8,6,7,3] size = 6
```
有了这个定义，我们很容易知道，对于数组中任意一个`i`位置的数：
1. 它的左孩子的位置是：`i * 2 + 1`
2. 它的右孩子的位置是：`i * 2 + 2`
3. 它的父亲的位置是：`(i-1) / 2`

# 堆
堆是一棵数组实现的完全二叉树，而且这个完全二叉树满足一个条件：
1. 对于大根堆，这棵树的所有子树，**其最大的数都在根节点**。
2. 对于小根堆，这棵树的所有子树，**其最小的数都在根节点**。

举例：
```
比如这是个大根堆：
          10
        /    \
       8      2
      / \    /
     6   7   1
1. 整棵树的最大值是10，在根节点
2. 左子树的最大值是8，在根节点
3. 右子树的最大值是2，在根节点
```
小根堆和大根堆是一样的，只不过最小的在根节点，这里就不多举例了。

## 大根堆实现逻辑
如何实现一个大根堆呢？大根堆需要实现3个功能：
1. `Push(num int)`向大根堆中加入一个数，不管这个数多大，都维持成一个大根堆。
2. `Pop() int`从大根堆中弹出最大的数（0位置），剩下的数仍然维持成大根堆。
3. `isEmpty()bool`大根堆是否是空的。

### 向大根堆中添加一个数
当我们在一个堆中添加一个数后（一定在最后一层的最后一个叶子节点位置），将这个数与其父亲比较。
1. 如果比父亲小，或者与父亲相等，则不变。
2. 如果比父亲大，则与父亲交换，交换到父亲的位置后，继续与父亲比较，还是比父亲大，则继续交换。
3. 2过程一直进行到不比当前的父亲大，或者已经到0位置（整棵树的根节点），则停止。

### 向大根堆中弹出一个数
先将0位置的数和大根堆中的最后位置的数交换，并弹出最后位置的数。最后将0位置的数不断与左右孩子的较大者比较：
1. 如果比max(左孩子，右孩子)小，则与较大者交换
2. 不比max(左孩子，右孩子)小，或者没有左右孩子了，则停止。


## 代码实现

### 1.heapInsert函数

`heapInsert(data []int, index int)`从index位置不断执行以下逻辑：

与父节点比较，如果比父节点大，则和父节点交换，直到不比父节点大，或者到了0位置。实现逻辑如下：
```go
func (heap *MaxHeap) heapInsert(arr []int, index int) {
	// 如果index位置比(index - 1)/2位置大，则交换
	// 如果index已经是0，(0 - 1)/2 也是0，不会被交换
	for arr[index] > arr[index-1]>>1 {
		swap(arr, index, (index - 1) >> 1)
		index = (index - 1) >> 1
	}
}
```

### 2.heapify函数
`heapify`函数能将i位置为节点的树，自上而下调整成大根堆（所有子树都已经是大根堆的前提下）
1. 获取左右子树中较大的树
2. 如果比左右子树中较大的树小，则与左右子树较大者交换，重复这个过程
3. 如果没有左右子树了，则停止
4. 如果不比左右子树中较大者小，则也停止

```go
func (heap *MaxHeap) heapify(arr []int, index int, heapSize int) {
	// 左孩子 index * 2 + 1 如果有右孩子，则右孩子是 left + 1
	left := index*2 + 1
	// 当前堆最后一个数的位置是 heapSize - 1
	for left < heap.heapSize {
		// 比较左右孩子，找到较大的，将位置给largest
		largest := left
		// 如果有又孩子，且右孩子比左孩子大，则右孩子给largest
		if left+1 < heap.heapSize && arr[left+1] > arr[left] {
			largest = left + 1
		}
		// 找到index和largest中谁最大，给largest
		if arr[index] > arr[largest] {
			largest = index
		}
		// 如果largest==index，说明左右孩子都不比当前位置的数大，则停止
		if largest == index {
			break
		}
		swap(arr, largest, index)
		index = largest
		// 找到下一个左孩子
		left = index*2 + 1
	}
}
```
### 3.整体代码实现
[code02_heap.go](code02_heap.go)

## 关于堆的总结：
> 1. 向堆中Push一个数的时间复杂度是O(logN)，因为`heapInsert`过程执行的次数，最坏情况是这个数比所有数都大，要向上替换到位置，执行次数是树的高度，而树的高度为O(logN)。
> 2. 同理，从堆中Pop一个数的时间复杂度也是O(logN)，因为`heapify`的执行过程也是O(logN)的。

# 堆排序
给定一个无序的数组，使用堆实现从小到大将数组排好序。

## 堆排序的思路：
堆排序的过程主要有以下几个步骤：
1. 先将整个数组调整成一个大根堆，此时0位置就是最大的数。
2. 将0位置与最后位置交换，heapSize--，并执行`heapify(arr,0,heapSize)`，此时n-1位置的数就定下来了，是全局最大的数，且[0,n-2]范围重新调整成了大根堆。
3. 将0位置与n-2位置交换，heapSize--，并执行`heapify(arr,0,heapSize)`，此时n-2位置的数也定下来了，是全局倒数第二大的数，且[0,n-3]范围重新调整成了大根堆。
4. 不断重复以上过程，直到整个数组有序。

### 如何将数组全局调整成大根堆？
怎么将全局调整成大根堆呢？很简单，我们把数组中的数，当做一个个Push到堆中的过程，堆每次Push都会执行一次heapInsert。
在执行完后，整个数组就成了一个大根堆。
具体代码如下：
```go
for i := 0; i < len(arr); i++ {
	heapInsert(arr, i)
}
```
这个过程的时间复杂度是O(N*logN)的。

**优化全局调整大根堆为O(N)**

将全局调整成大根堆，也有O(N)的方法，由于数组中的数是全部一起给的，我们可以从N-1位置往前遍历，每次都执行一次`heapify`，代码如下：
```go
for i:= len(arr)-1; i >= 0; i-- {
	heapify(arr, i, len(arr))
}
```
这个过程遍历过程中，每次都能保证当前`i`位置为根的数，其左右子树都比当前数小（大的会heapify交换上来）。整体执行完，整颗树就是个大根堆。但是为啥能做到O(N)的时间复杂度呢？因为是从最后一层开始遍历的

- 倒数第一层占全局数量的1/2，最后一层的每个数都没有左右孩子，只看了一眼，不用交换，只看自己1次。
- 倒数第二层占全局数量的1/4，比较大小并交换1层到底，2次
- 倒数第三层占全局数量的1/8，比较大小并交换2层到底，3次
- 倒数第四层占全局数量的1/16，比较大小并交换2层到底，4次
...

所以整体的时间复杂度可以是以下的公式：
```
T(N)  = N/2*1 + N/4 * 2 + N/8*3 + N/16 * 4 + ...
2T(N) = N     + N/2 * 2 + N/4*3 + N/8 * 4  + ...
公式2减公式1得（错位减，公式2的第2项减去公式1的第1项）
T(N)  = N + N/2 + N/4 + N/8 + ...


这是个等比数列，一定收敛于O(N)
```
其实也很好理解，方式2数据量越大的层，做的操作次数越少。而方式1正好相反，数据量越大的层，做的操作次数也越多。

## 堆排序的代码实现：
```go
func HeapSort(arr []int) {
	// 1. 先将整个数组调整成大根堆
	//for i := 0; i < len(arr); i++ {
	//	heapInsert(arr, i)
	//}
	// 方式2 O(N)
    for i:= len(arr)-1; i >= 0; i-- {
        heapify(arr, i, len(arr))
    }
	// 2. 不断将0位置与堆最后的位置进行交换，并重新调整成大根堆
	heapSize := len(arr)
	for heapSize > 0 {
		// 将0位置与堆的最后位置交换
		swap(arr, 0, heapSize-1)
		// 堆大小减1，固定最后位置的数
		heapSize--
		// 重新调整成大根堆
		heapify(arr, 0, heapSize)
	}
}
```

具体代码见：[code03_heap_sort.go](code03_heap_sort.go)

## 堆相关面试题
### 1.给一个几乎有序的数组排序
已知一个几乎有序的数组，几乎有序是指，如果把数组调整排好序的话，每个元素移动的距离一定不超过k，并且k相对于数组长度来说是比较小的。

请选择一个合适的排序策略，对这个数组进行排序。

#### 1.1.分析
根据题意可知，我们要确定0位置的数（0位置最小），只需要从`0~k`范围内找最小值，因为k+1往后的数如果是全局最小值，移动到0位置的距离就超过k了，题目条件不允许。
同理，0位置确定后，1位置的数，只需要从`[1,k+2]`范围内找最小值。这样我们就能通过堆来解决了：
> 1. 从`0~k`范围内创建大小为`K+1`的小根堆，建完之后，弹出最小值放到0位置。
> 2. 把k+1位置加入小根堆，弹出最小值放到1位置。
> 3. 把k+2位置加入小根堆，弹出最小值放到2位置。
> ...
> 没有数可以加到堆了，则把堆中剩下的数依次弹出，直到把堆弹空。

#### 1.2 代码实现
```go
// SortedArrDistanceLessK 几乎有序数组排序
func SortedArrDistanceLessK(arr []int, k int) {
	// 初始化一个小根堆
	minHeap := NewMyHeap[int](func(a int, b int) bool {
		return a < b
	})
	index := 0
	// 从堆中弹出再写入arr的下个位置
	popIndex := 0
	// [0 ~ k]范围创建一个小根堆（k可能比数组长度大，所以这里求下最小值）
	for ; index <= utils.Min(k, len(arr)-1); index++ {
		minHeap.Push(arr[index])
	}
	// k + 1位置开始，弹出一个写回原数组，再加入一个，直到所有数都加入完了
	for ; index < len(arr); index++ {
		// 弹出最小值，放到popIndex位置
		arr[popIndex] = minHeap.Pop()
		popIndex++
		// 将index位置的数push到堆中
		minHeap.Push(arr[index])
	}
	// 最后将堆弹空并写入arr
	for !minHeap.IsEmpty() {
		arr[popIndex] = minHeap.Pop()
		popIndex++
	}
}
```

#### 1.2.时间复杂度
由于堆的push和pop都是O(logN)的复杂度，但是堆的大小限制在了K，所以每次Pop再Push的代价是O(logK)，所以，整体的时间复杂度是`O(N * logK)`

代码详见：[code04_sort_array_distance_less_k.go](code04_sort_array_distance_less_k.go#L14)

### 2.最大线段重合问题
给定很多个线段，每个线段都有两个数[start, end]，表示线段的开始位置和结束位置，左右都是闭区间，规定：
1. 线段的开始位置和结束位置一定都是整数值。
2. 线段的重合区域长度必须 >= 1。

请返回线段的最多重合区域中，包含了几条线段。

#### 2.1 分析
首先，按照题意，只有一个点重合的，不算重合。比如 a线段是`[1,2]` b线段是`[2,5]`，虽然点2是重合的，但是重合部分只有一个点，长度是0，不算重合。

其次，任意一个重合区域的左边界，必定至少是有1条线段的左边界，这个也很好理解，比如线段`[3,5]`和线段`[4,6]`以及线段`[4,8]`的共同重合区域是`[4,5]`，而这个重合线段的左边界`4`也是`[4,6]`和`[4,8]`的左边界。

##### 笨办法
遍历线段数组，统计出所有线段最小的左边界，以及最大的右边界。比如最小是1，最大是1000，那么重合区域肯定在[1,1000]范围内。
然后我们统计[1,1000]中，每个0.5的位置，有多少个线段穿过。1.5 2.5 3.5 一直到999.5，并获取最大值。

这个方法弊病很大，假如最小和最大值的区域特别大，则需要统计的循环范围就特别大。
比如线段数组是{[-1000000,-999999] 与 [1,10000000000]} 虽然只有两个线段，但是需要遍历100亿次。

##### 使用堆的方式来实现
我们将所有线段**由左边界从小到大排序**，然后依次统计每个线段的左边界**有多少其他线段的右边界穿过当前左边界**，则这个值就是
以当前值为左边界的重复的线段的条数，问题是如何统计，这就需要用到小根堆了。流程如下：
1. 先将整个线段数组，按照**左边界从小到大**的顺序排序，并准备一个小根堆。
2. 遍历数组，假设当前遍历到的左边界是x，则将小根堆中所有 <= x 的值弹出
3. 将当前线段的右边界压入到小根堆。
4. 统计此时小根堆的大小，就是**以x为左边界的重合线段的数量**。

比如我们有个线段数组`[[3,4],[2,3],[1,2],[2,8],[1,5]]`
1. 按照左边界从小到大排序，变成`[[1,3],[1,5],[2,3],[2,8],[3,4]]`，准备小根堆:`{}`
2. 线段`[1,3]`，堆为空，不需要弹出，将3压入小根堆, `{3}`，此时以1开头的重复区域有1个。
3. 线段`[1,5]`，堆中没有<=1的，不弹出，压入5，`{3,5}`，此时1开头的重复区域有2个。
4. 线段`[2,3]`, 堆中没有<=2的，不弹出，压入3，`{3,3,5}`，此时以2开头的重复区域有3个。
5. 线段`[2,8]`，堆中没有<=2的，压入8，`{3,3,5,8}`，此时以2开头的重复区域有4个。
6. 线段`[3,8]`，堆中3<=3，弹出3，压入8，`{5,8,8}`，此时以3开头的重复区域有3个。

综上，所有的线段中，重复线段最多的，包含了4条线段。

这个流程我们清楚了，那这是什么原理呢？

首先，我们先按照左边界从小到大排序了，遍历是按照这个排序好的顺序进行的，然后**堆中存放的是已经遍历过的线段的右边界**。
1. 假设遍历到了某个以`x`（左边界）开头的线段`a`，那么堆中有个`<=x`的数，说明什么？ 说明这个数对应的线段**右边界<=当前线段的左边界**，则必定不会与当前线段重复。所以要弹出。
2. 还是`a`线段为例，堆中`>x`的数表示什么？表示这些线段的**开始<=x，且结束>x**，则这些线段**肯定穿过了当前的x位置**（相当于判断是否与区域`[x,x+1]`重合，或者是否包含x+0.5这个点)，再加上当前线段a本身也符合，所以将a的又边界也压入堆，堆的大小就是以x为左边界的重复区域的线段数。
3. 如果后面还有以`x`开头的线段呢？会继续压入到小根堆中，基于x的统计值会继续+1，**所以遍历完所有`x`开头的线段，小根堆的大小就是正确值**。
4. 如果遍历到了假如x+1开头，那么统计的就是以x+1为左边界的重复区域的重合线段个数了，不再是x的了，**而且以后的线段都不可能会被统计到x开头的区域中**，这是为什么呢？因为**遍历顺序是按开始区域从小到大排序的**。

经过上面4条分析，每次遍历完一个左边界x，当前的堆的大小，就是穿过了x的所有重复线段的条数。

#### 2.2 代码实现
[code05_cover_max.go](code05_cover_max.go)

# 手写堆
很多语言提供的堆结构，只能提供这几个最基本的功能：
1. 向堆中push一个元素 
2. 从堆中Pop一个元素 
3. 获取堆顶的元素
4. 获取堆的大小
Go语言提供的堆，提供了`Push`,`Pop`,`Remove`和`Fix`4个功能，还算比较全面的。有时候我们需要使用堆的额外的功能时，只能手动实现了，这里就需要手写堆。

比如，我们给了堆一个对象，已经被添加到堆中了，之后我们将这个对象的属性变了，且这个属性是参与堆的排序的，此时我们希望这个堆能将这个对象重新调整到正确的位置。此时系统的堆是无法实现的，因为系统提供的堆没有**反向索引表**。

例如你把`a`这个对象的年龄属性，从18改成了30，系统堆做不到调整，因为要调整，需要先知道`a`对象在数组中的位置，然后在`a`所在的位置，执行`heapify`往上调整，或者`heapInsert`往下调整。

如果一定要做到，只能一个个遍历先找到`a`的位置，这样时间复杂度就是O(N)了，而不是O(logN)了。

我们要实现这个功能，就要手写堆，**在堆中维护一个反向索引表**，记住每个元素在堆中的位置。

## 代码实现
代码详见[code06_heap_greater.go](code06_heap_greater.go)，在这个手写的堆结构，提供了系统堆不具备的额外的功能：
1. `Contains(obj T) bool`获取某个对象是否在堆中
2. `Remove(obj T)`删除堆中的某个对象
3. `Resign(obj T)`假如我改变了某个对象的值，这个对象在堆中，并且这个值是影响比较大小的，改完就不符合堆结构了，让堆重新调整成堆结构

这些额外的功能的时间复杂度都是O(logN)级别的。

