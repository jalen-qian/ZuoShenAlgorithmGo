# 堆
堆在很多语言中称为“优先级队列”，虽然名字有“队列”二字，但是底层实现实际上是一个堆。

堆是一个完全二叉树，且堆分为大根堆和小根堆。具体定义下面再讲。

# 完全二叉树
通俗解释：一个二叉树的上面的层一定是满的，不满的层是从左往右依次变满，那么这个二叉树是完全二叉树。

就是说，这个二叉树的任意节点，要么没有子树，在有子树时，不能**只有右子树没有左子树**，但可以只有左子树，无右子树。

比如下面的树是完全二叉树：
```
1. 空树是完全二叉树
2. 只有一个节点的数，也是完全二叉树
3. 下面的树前两层都是满的，最后一层不满，但是是在填满的过程中。
          2
        /   \
       5     8
      / \   /
     6   7  3
```

# 用数组实现一个完全二叉树
假设我们有个数组`arr`，和`size`变量。将它想象成一个完全二叉树的结构，**规定数组中的数的顺序，就是我们创建这个完全二叉树时添加数的顺序**。

从逻辑上可以把这个数组想象成一个完全二叉树。完全二叉树的添加顺序是从上到下，从左到右的。而`size`变量规定数组中前`size`个数在这个逻辑上的二叉树中，剩下的数都是无效的。

比如上面例子3中的完全二叉树，对应的数组是:
```
[2,5,8,6,7,3] size = 5
```
有了这个定义，我们很容易知道，对于数组中任意一个`i`位置的数：
1. 它的左孩子的位置是：`i * 2 + 1`
2. 它的右孩子的位置是：`i * 2 + 2`
3. 它的父亲的位置是：`(i-1) / 2`

# 堆
堆是一棵数组实现的完全二叉树，而且这个完全二叉树满足一个条件：
1. 对于大根堆，这棵树的所有子树，**其最大的数都在根节点**。
2. 对于小根堆，这棵树的所有子树，**其最小的数都在根节点**。

举例：
```
比如这是个大根堆：
          10
        /    \
       8      2
      / \    /
     6   7   1
1. 整棵树的最大值是10，在根节点
2. 左子树的最大值是8，在根节点
3. 右子树的最大值是2，在根节点
```
小根堆和大根堆是一样的，只不过最小的在根节点，这里就不多举例了。

## 大根堆实现逻辑
如何实现一个大根堆呢？大根堆需要实现3个功能：
1. `Push(num int)`向大根堆中加入一个数，不管这个数多大，都维持成一个大根堆。
2. `Pop() int`从大根堆中弹出最大的数（0位置），剩下的数仍然维持成大根堆。
3. `isEmpty()bool`大根堆是否是空的。

### 向大根堆中添加一个数
当我们在一个堆中添加一个数后（一定在最后一层的最后一个叶子节点位置），将这个数与其父亲比较。
1. 如果比父亲小，或者与父亲相等，则不变。
2. 如果比父亲大，则与父亲交换，交换到父亲的位置后，继续与父亲比较，还是比父亲大，则继续交换。
3. 2过程一直进行到不比当前的父亲大，或者已经到0位置（整棵树的根节点），则停止。

### 向大根堆中弹出一个数
先将0位置的数和大根堆中的最后位置的数交换，并弹出最后位置的数。最后将0位置的数不断与左右孩子的较大者比较：
1. 如果比max(左孩子，右孩子)小，则与较大者交换
2. 不比max(左孩子，右孩子)小，或者没有左右孩子了，则停止。


## 代码实现

### 1.heapInsert函数

`heapInsert(data []int, index int)`从index位置不断执行以下逻辑：

与父节点比较，如果比父节点大，则和父节点交换，直到不比父节点大，或者到了0位置。实现逻辑如下：
```go
func (heap *MaxHeap) heapInsert(arr []int, index int) {
	// 如果index位置比(index - 1)/2位置大，则交换
	// 如果index已经是0，(0 - 1)/2 也是0，不会被交换
	for arr[index] > arr[index-1]>>1 {
		swap(arr, index, (index - 1) >> 1)
		index = (index - 1) >> 1
	}
}
```

### 2.heapify函数
`heapify`函数能将i位置为节点的树，自上而下调整成大根堆（所有子树都已经是大根堆的前提下）
1. 获取左右子树中较大的树
2. 如果比左右子树中较大的树小，则与左右子树较大者交换，重复这个过程
3. 如果没有左右子树了，则停止
4. 如果不比左右子树中较大者小，则也停止

```go
func (heap *MaxHeap) heapify(arr []int, index int, heapSize int) {
	// 左孩子 index * 2 + 1 如果有右孩子，则右孩子是 left + 1
	left := index*2 + 1
	// 当前堆最后一个数的位置是 heapSize - 1
	for left < heap.heapSize {
		// 比较左右孩子，找到较大的，将位置给largest
		largest := left
		// 如果有又孩子，且右孩子比左孩子大，则右孩子给largest
		if left+1 < heap.heapSize && arr[left+1] > arr[left] {
			largest = left + 1
		}
		// 找到index和largest中谁最大，给largest
		if arr[index] > arr[largest] {
			largest = index
		}
		// 如果largest==index，说明左右孩子都不比当前位置的数大，则停止
		if largest == index {
			break
		}
		swap(arr, largest, index)
		index = largest
		// 找到下一个左孩子
		left = index*2 + 1
	}
}
```
### 3.整体代码实现
[code02_heap.go](code02_heap.go)

## 关于堆的总结：
> 1. 向堆中Push一个数的时间复杂度是O(logN)，因为`heapInsert`过程执行的次数，最坏情况是这个数比所有数都大，要向上替换到位置，执行次数是树的高度，而树的高度为O(logN)。
> 2. 同理，从堆中Pop一个数的时间复杂度也是O(logN)，因为`heapify`的执行过程也是O(logN)的。

# 堆排序
给定一个无序的数组，使用堆实现从小到大将数组排好序。

## 堆排序的思路：
堆排序的过程主要有以下几个步骤：
1. 先将整个数组调整成一个大根堆，此时0位置就是最大的数。
2. 将0位置与最后位置交换，heapSize--，并执行`heapify(arr,0,heapSize)`，此时n-1位置确定了，且[0,n-2]范围重新调整成了大根堆。
3. 将0位置与n-2位置交换，heapSize--，并执行`heapify(arr,0,heapSize)`，此时n-2位置确定了，且[0,n-3]范围重新调整成了大根堆。
4. 不断重复以上过程，直到整个数组有序。

### 如何将数组全局调整成大根堆？
怎么将全局调整成大根堆呢？很简单，我们把数组中的数，当做一个个Push到堆中的过程，堆每次Push都会执行一次heapInsert。
在执行完后，整个数组就成了一个大根堆。
具体代码如下：
```go
for i:=0; i < len(arr); i++{
	heapInsert(arr, i)
}
```
这个过程的时间复杂度是O(N*logN)的。

**优化全局调整大根堆为O(N)**

将全局调整成大根堆，也有O(N)的方法，由于数组中的数是全部一起给的，我们可以从N-1位置往前遍历，每次都执行一次`heapify`，代码如下：
```go
for i:= len(arr)-1; i >= 0; i-- {
	heapify(arr, i, len(arr))
}
```
这个过程遍历过程中，每次都能保证当前`i`位置为根的数，其左右子树都比当前数小（大的会heapify交换上来）。整体执行完，整颗树就是个大根堆。但是为啥能做到O(N)的时间复杂度呢？因为是从最后一层开始遍历的

- 倒数第一层占全局数量的1/2，最后一层的每个数都没有左右孩子，只看了一眼，不用交换，只看自己1次。
- 倒数第二层占全局数量的1/4，比较大小并交换1层到底，2次
- 倒数第三层占全局数量的1/8，比较大小并交换2层到底，3次
- 倒数第四层占全局数量的1/16，比较大小并交换2层到底，4次
...

所以整体的时间复杂度可以是以下的公式：
```
T(N)  = N/2*1 + N/4 * 2 + N/8*3 + N/16 * 4 + ...
2T(N) = N     + N/2 * 2 + N/4*3 + N/8 * 4  + ...
公式2减公式1得（错位减，公式2的第2项减去公式1的第1项）
T(N)  = N + N/2 + N/4 + N/8 + ...


这是个等比数列，一定收敛于O(N)
```
其实也很好理解，方式2数据量越大的层，做的操作次数越少。而方式1正好相反，数据量越大的层，做的操作次数也越多。

## 堆排序的代码实现：
```go
func HeapSort(arr []int) {
	// 1. 先将整个数组调整成大根堆
	//for i := 0; i < len(arr); i++ {
	//	heapInsert(arr, i)
	//}
	// 方式2 O(N)
    for i:= len(arr)-1; i >= 0; i-- {
        heapify(arr, i, len(arr))
    }
	// 2. 不断将0位置与堆最后的位置进行交换，并重新调整成大根堆
	heapSize := len(arr)
	for heapSize > 0 {
		// 将0位置与堆的最后位置交换
		swap(arr, 0, heapSize-1)
		// 堆大小减1，固定最后位置的数
		heapSize--
		heapify(arr, 0, heapSize)
	}
}
```

具体代码见：[code03_heap_sort.go](code03_heap_sort.go)

## 堆相关面试题
### 1.题目描述
已知一个几乎有序的数组，几乎有序是指，如果把数组调整排好序的话，每个元素移动的距离一定不超过k，并且k相对于数组长度来说是比较小的。

请选择一个合适的排序策略，对这个数组进行排序。

### 2.分析
根据题意可知，我们要确定0位置的数（0位置最小），只需要从`0~k`范围内找最小值，因为k+1往后的数如果是全局最小值，移动到0位置的距离就超过k了。
同理，0位置确定后，1位置的数，只需要从`[1,k+2]`范围内找最小值。这样我们就能通过堆来解决了：
> 1. 从`0~k`范围内创建大小为`K+1`一个小根堆，建完之后，弹出最小值放到0位置。
> 2. 把k+1位置加入小根堆，弹出最小值放到1位置。
> 3. 把k+2位置加入小根堆，弹出最小值放到2位置。
> ...
> 没有数可以加到堆了，依次弹出，把堆弹空就行了。

### 3.时间复杂度
O(N * logK)

代码详见：