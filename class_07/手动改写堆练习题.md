# 练习题1
## 题目描述
给定一个整型数组，int[] arr；和一个布尔类型数组，boolean[] op

两个数组一定等长，假设长度为N，arr[i]表示客户编号，op[i]表示客户操作
> arr = [ 3, 3, 1, 2, 1, 2, 5… <br>
> op  = [ T, T, T, T, F, T, F…

依次表示：3用户购买了一件商品，3用户购买了一件商品，1用户购买了一件商品，2用户购买了一件商品，1用户退货了一件商品，2用户购买了一件商品，5用户退货了一件商品…

一对`arr[i]`和`op[i]`就代表一个事件：
- 用户号为arr[i]，op[i] == T就代表这个用户购买了一件商品
- op[i] == F就代表这个用户退货了一件商品

现在你作为电商平台负责人，你想在每一个事件到来的时候，
**都给购买次数最多的前K名用户颁奖**。
所以每个事件发生后，你都需要一个得奖名单（得奖区）。

得奖系统的规则：
1. 如果某个用户购买商品数为0，但是又发生了退货事件， **则认为该事件无效**，得奖名单和上一个事件发生后一致，例子中的5用户
2. 某用户发生购买商品事件，购买商品数+1，发生退货事件，购买商品数-1
3. 每次都是最多K个用户得奖，K也为传入的参数。 如果根据全部规则，得奖人数确实不够K个，那就以不够的情况输出结果
4. 得奖系统分为得奖区和候选区，任何用户只要购买数>0，**一定在这两个区域中的一个**
5. 购买数最大的前K名用户进入得奖区， 在最初时如果得奖区没有到达K个用户，那么新来的用户直接进入得奖区
6. 如果购买数不足以进入得奖区的用户，进入候选区
7. 如果候选区购买数最多的用户，已经足以进入得奖区， 
**该用户就会替换得奖区中购买数最少的用户**（大于才能替换），
如果得奖区中购买数最少的用户有多个，就**替换最早进入得奖区的用户**
如果候选区中购买数最多的用户有多个，**机会会给最早进入候选区的用户**
8. 候选区和得奖区是两套时间，
因用户只会在其中一个区域，所以只会有一个区域的时间，另一个没有。从得奖区出来进入候选区的用户，得奖区时间删除。<br>
进入候选区的时间就是当前事件的时间（可以理解为arr[i]和op[i]中的i）<br>
从候选区出来进入得奖区的用户，候选区时间删除，<br>
进入得奖区的时间就是当前事件的时间（可以理解为arr[i]和op[i]中的i）

请遍历arr数组和op数组，遍历每一步输出一个得奖名单
```go
func TopK (arr []int, op []bool, int k)[][]int {}
```

## 实现
### 1.使用暴力方法实现
代码详见：[code07_every_step_show_boss.go](code07_every_step_show_boss.go#L171)
#### 时间复杂度
暴力方法使用数组存得奖区和候选区的元素，遍历过程中，每次候选区的区域会进行排序排序过程是 O(N*logN)，每次还会进行一次删除购买数为0的用户，这个会遍历一遍，时间复杂度是O(N)
其他的操作都是常数时间，整体看时间复杂度是O(N^2 * logN)

### 2. 使用手写堆方式实现
代码详见：[code07_every_step_show_boss.go](code07_every_step_show_boss.go#L53)
#### 时间复杂度
手写堆方式将得奖区和候选区存储在堆中，其中得奖区堆的大小是k，每次遍历调整的代价是O(logK)，候选区的堆大小与元素数量N是一个级别的。每次调整的代价是O(logN)，所以整体的时间复杂度是O(N*logN)
