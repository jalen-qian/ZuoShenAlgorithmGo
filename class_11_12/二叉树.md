# 二叉树
二叉树是经典的数据结构，拥有一个Value和左右两个子树。

## 二叉树的遍历
二叉树的遍历一般分为**先序遍历**，**中序遍历**和**后序遍历**3种。
1. 先序遍历：先打印根节点，再打印左子树，最后打印右子树。
2. 中序遍历：先打印左子树，再打印根节点，最后打印右子树。
3. 后序遍历：先打印左子树，再打印右子树，最后打印根节点。

这3种遍历其实都是人为规定的，总共的遍历方式其实有6种，比如先打印右子树，再打印左子树，最后打印根节点，这种算什么遍历呢？

另外，二叉树的遍历还有按层遍历，即按照每层依次从左往右打印，比如
```
      1      
    /   \    
  2       3  
 / \     / \ 
4   5   6   7
遍历就是：1 2 3 4 5 6 7
```

### 递归方式遍历二叉树
#### 1.先序遍历
```go
// Pre 先序遍历
func (r *RecursiveTraversalBT) Pre(root *Node) {
	if root == nil {
		return
	}
	// 先打印根节点
	fmt.Printf("%d ", root.Value)
	// 再打印左子树
	r.Pre(root.Left)
	// 再打印右子树
	r.Pre(root.Right)
}
```

#### 2.中序遍历
```go
// In 中序遍历
func (r *RecursiveTraversalBT) In(root *Node) {
	if root == nil {
		return
	}
	// 先打印左子树
	r.In(root.Left)
	// 再打印自己
	fmt.Printf("%d ", root.Value)
	// 最后打印右子树
	r.In(root.Right)
}
```

#### 3.后序遍历
```go
// Pos 后序遍历
func (r *RecursiveTraversalBT) Pos(root *Node) {
	if root == nil {
		return
	}
	// 先打印左子树
	r.Pos(root.Left)
	// 再打印右子树
	r.Pos(root.Right)
	// 最后打印自己
	fmt.Printf("%d ", root.Value)
}
```

### 递归序
递归序指的是，在遍历过程中，每个节点都会到达3次，第1次是遍历到当前节点，第2次是遍历完左子树，回到当前节点，第3次是遍历完又子树，回到当前节点。
```go
func f(root *Node) {
	if root == nil {
		return
	}
	fmt.Println("第一次到达")
	// 遍历左子树
	f(root.Left)
	fmt.Println("第二次到达")
	// 遍历右子树
	f(root.Right)
	fmt.Println("第三次到达")
}
```
先序遍历的本质就是**第1次到达当前节点时打印**。<br>
中序遍历的本质就是**第2次到达当前节点时打印**。<br>
后序遍历的本质就是**第3次到达当前节点时打印**。


### 使用非递归的方式遍历二叉树

#### 1.先序遍历
准备一个栈，然后流程如下
1. 将根节点入栈，栈不空就一直遍历
2. 弹出栈顶元素并给cur，弹出就打印。
3. 如果有右子树，右子树入栈，如果有左子树，左子树入栈(先入左再入右)
4. 不断重复2和3步骤，直到栈弹空。

理解：对于每一颗子树来说，都是先根节点入栈，再弹出，然后右子树入栈再左子树入栈。所以弹出时是
先弹出根，再左再右，每颗子树都是如此，所以整体的顺序就是先序遍历的顺序。


代码如下：
```go
// Pre 先序遍历
func (r *UnRecursiveTraversalBT) Pre(root *Node) {
	if root == nil {
		return
	}
	// 创建一个栈，并先把根节点压入
	stack := class_03.NewMyStack[*Node]()
	stack.Push(root)
	for !stack.IsEmpty() {
		cur := stack.Pop()
		// 出栈就打印
		fmt.Printf("%d ", cur.Value)
		// 有右子树，就入栈
		if cur.Right != nil {
			stack.Push(cur.Right)
		}
		// 有左子树，就入栈
		if cur.Left != nil {
			stack.Push(cur.Left)
		}
	}
	fmt.Println()
}
```

#### 2.后续遍历
从先序遍历的流程，我们用栈实现了先头再左再右的先序遍历顺序打印，用的方式是头入栈之后出栈，然后将头的右左子树分别入栈。

那么我们也可以实现先头再右再左的打印，方式是弹出头后，先入栈左子树，再入栈右子树。

进一步，上面的流程是**一出栈就打印**，如果我们在上面的基础上改动，一出栈就不打印，而是压入另一个栈。整个事情做完之后，再将另一个栈依次打印。

那么，最后打印的顺序是 头右左 的逆序，也就是 左右头，也就实现了后序遍历。

代码如下：
```go
// Pos1 后序遍历
func (r *UnRecursiveTraversalBT) Pos1(root *Node) {
	if root == nil {
		return
	}
	s1 := class_03.NewMyStack[*Node]()
	s2 := class_03.NewMyStack[*Node]()
	s1.Push(root)
	for !s1.IsEmpty() {
		head := s1.Pop()
		// 只要出栈，不打印，而是压入另一个栈
		s2.Push(head)
		// 弹出后依次压入左和右，实现整体 头 右 左 的顺序弹出
		if head.Left != nil {
			s1.Push(head.Left)
		}
		if head.Right != nil {
			s1.Push(head.Right)
		}
	}
	// 所有事情做完，依次将s2弹出
	for !s2.IsEmpty() {
		fmt.Printf("%d ", s2.Pop().Value)
	}
}
```

#### 4. 怎么只使用一个栈，实现后序遍历
这个流程很难，基本上面试官也没有多少会的，左神在课上没讲，只给了代码，可以掌握也可以不掌握。代码如下：
```java
	public static void pos2(Node h) {
		System.out.print("pos-order: ");
		if (h != null) {
			Stack<Node> stack = new Stack<Node>();
			stack.push(h);
			Node c = null;
			while (!stack.isEmpty()) {
				c = stack.peek();
				if (c.left != null && h != c.left && h != c.right) {
					stack.push(c.left);
				} else if (c.right != null && h != c.right) {
					stack.push(c.right);
				} else {
					System.out.print(stack.pop().value + " ");
					h = c;
				}
			}
		}
		System.out.println();
	}
```

#### 5.中序遍历
中序遍历是先左子树，然后头节点，最后右子树。对于不管多高的二叉树，**最先遍历到的，一定是左边界的最后一个节点**，然后是头节点和右子树。<br>
所以中序遍历的本质是，**将整颗树按照左边界做了一个拆分**。

中序遍历的流程如下：

准备一个栈和一个cur变量，初始时cur指向根节点，循环条件是**栈不为空或者cur不为空**（栈为空且cur为空，就退出）
1. 如果cur不为空，cur入栈，cur跳到cur的左子树。
2. 如果cur为空，则**栈弹出一个节点给cur接收，同时打印，同时cur指向cur的右子树**。
3. 重复上述过程，直到cur为空且栈也弹空了，退出。

具体实例：
```
我们以这颗树为例：
      1      
    /   \    
  2       3  
 / \     / \ 
4   5   6   7
1. 初始cur不断往左边界走，直到走到4，一直入栈，stack = 1 2 4  栈顶是4，此时cur走到4的左孩子，是空
2. 弹出4打印，栈是 1 2，cur指向4的右孩子，cur又是空
3. 弹出2打印，栈是 1，cur指向2的右孩子为5，不为空，5入栈，栈是 1 5，cur来到5的左孩子，是空
4. 弹出5打印，栈是 1，cur指向5的右孩子为空
5. 弹出1打印，栈是空，cur指向1的右孩子，是3
6. 3入栈，栈是3，cur指向3的左孩子6
7. 6入栈，栈是3 6，cur指向6的左孩子，为空
8. 弹出6打印，栈是3，cur指向6的右孩子为空
9. 弹出3打印，栈为空，cur指向3的右孩子7
10.7入栈，栈是7，cur指向7的左孩子，是空
11.弹出7打印，cur指向7的右孩子，是空，此时栈是空，cur也是空，循环退出。
至此，依次打印了 4 2 5 1 6 3 7
```
代码如下：
```go
// In 中序遍历
func (r *UnRecursiveTraversalBT) In(root *Node) {
	if root == nil {
		return
	}
	// 创建一个栈，如果当前节点有左孩子，就压入，并不断往左边界靠
	stack := class_03.NewMyStack[*Node]()
	cur := root
	for !stack.IsEmpty() || cur != nil {
		if cur != nil {
			stack.Push(cur)
			cur = cur.Left
		} else {
			cur = stack.Pop()
			fmt.Printf("%d ", cur.Value)
			cur = cur.Right
		}
	}
	fmt.Println()
}
```

#### 6.实现按层遍历
如果将二叉树理解为图，则按层遍历是宽度优先搜索，用队列实现。

准备一个队列，并先将根节点放队列里。
1. 从队列里弹出一个节点，打印，并给cur
2. cur如果有左孩子，左孩子入队列，如果有右孩子，右孩子入队列
3. 循环1 2步骤，直到队列为空。

举例：
```
我们以这颗树为例：
      1      
    /   \    
  2       3  
 / \     / \ 
4   5   6   7
1. 1入队列
2. 1弹出，打印，1给cur，cur的左右子树入队列[2,3]
3. 2弹出，打印，2给cur，cur的左右子树入队列[3,4,5]
4. 3弹出，打印，3个cur，cur的左右子树入队列[4,5,6,7]
5. 4弹出，打印，无左右子树，不入队列
6. 5弹出，打印，无左右子树，不入队列
7. 6弹出，打印，无左右子树，不入队列
8. 7弹出，打印，入左右子树，不入队列

综上，整体打印顺序是 1 2 3 4 5 6 7 按照层遍历。
```
总结：这个流程是按照层遍历的，但是我们不知道遍历时每一层的开始和结束。有些算法题需要直到，比如求最大的层宽度。


## 二叉树的序列化和反序列化
给一个内存中的二叉树，能将这个二叉树用某种规则转换成一个唯一的字符串，并且可以根据这个字符串反转成当前唯一的二叉树。这就是序列化和反序列化。

常规的方式是按**先序遍历方式序列化**和按**层遍历方式序列化**。

比如：先序遍历中，遇到nil不忽略，用#表示，遇到正常节点，拼接值，并所有都用`,`隔开。
```
               1      
        /              \    
        2               3  
     /    \           /     \ 
    4       5        6       7
   /\      / \      / \     / \
 nil nil nil nil   nil nil nil nil
 
先序方式序列化就是： "1,2,4,#,#,5,#,#,3,6,#,#,7,#,#"

反序列化时，也是按照先序的方式重新建树
```

二叉树可以通过先序、后序或者按层遍历的方式序列化和反序列化。
但是，二叉树无法通过中序遍历的方式实现序列化和反序列化
因为不同的两棵树，可能得到同样的中序序列，即便补了空位置也可能一样。
比如如下两棵树
```
        __2
       /
      1
      
      和
      1__
         \
          2
```
补足空位置的中序遍历结果都是{ null, 1, null, 2, null} （#,1,#,2,#）

### 关于空树
序列化成字符串，如果序列化后的值是"#"，不管是先序、后序还是按层遍历的方式，都表示只有一个节点，且为空（即空树）。而空字符串，也能表示空树。
为了避免歧义，我们这里规定序列化空树，一定序列化成"#"。反序列化时，如果出现了空字符串和"#"，则都反序列化为空树。


### 代码实现
[code04_serialize_and_reconstruct_tree.go](code04_serialize_and_reconstruct_tree.go)