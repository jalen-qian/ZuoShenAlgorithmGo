## 二叉树
二叉树是经典的数据结构，拥有一个Value和左右两个子树。

### 二叉树的遍历
二叉树的遍历一般分为**先序遍历**，**中序遍历**和**后序遍历**3种。
1. 先序遍历：先打印根节点，再打印左子树，最后打印右子树。
2. 中序遍历：先打印左子树，再打印根节点，最后打印右子树。
3. 后序遍历：先打印左子树，再打印右子树，最后打印根节点。

这3种遍历其实都是人为规定的，总共的遍历方式其实有6种，比如先打印右子树，再打印左子树，最后打印根节点，这种算什么遍历呢？

另外，二叉树的遍历还有按层遍历，即按照每层依次从左往右打印，比如
```
      1      
    /   \    
  2       3  
 / \     / \ 
4   5   6   7
遍历就是：1 2 3 4 5 6 7
```

#### 递归方式遍历二叉树
##### 1.先序遍历
```go
// Pre 先序遍历
func (r *RecursiveTraversalBT) Pre(root *Node) {
	if root == nil {
		return
	}
	// 先打印根节点
	fmt.Printf("%d ", root.Value)
	// 再打印左子树
	r.Pre(root.Left)
	// 再打印右子树
	r.Pre(root.Right)
}
```

##### 2.中序遍历
```go
// In 中序遍历
func (r *RecursiveTraversalBT) In(root *Node) {
	if root == nil {
		return
	}
	// 先打印左子树
	r.In(root.Left)
	// 再打印自己
	fmt.Printf("%d ", root.Value)
	// 最后打印右子树
	r.In(root.Right)
}
```

##### 3.后序遍历
```go
// Pos 后序遍历
func (r *RecursiveTraversalBT) Pos(root *Node) {
	if root == nil {
		return
	}
	// 先打印左子树
	r.Pos(root.Left)
	// 再打印右子树
	r.Pos(root.Right)
	// 最后打印自己
	fmt.Printf("%d ", root.Value)
}
```

#### 递归序
递归序指的是，在遍历过程中，每个节点都会到达3次，第1次是遍历到当前节点，第2次是遍历完左子树，回到当前节点，第3次是遍历完又子树，回到当前节点。
```go
func f(root *Node) {
	if root == nil {
		return
	}
	fmt.Println("第一次到达")
	// 遍历左子树
	f(root.Left)
    fmt.Println("第二次到达")
	// 遍历右子树
	f(root.Right)
    fmt.Println("第三次到达")
}
```
先序遍历的本质就是**第1次到达当前节点时打印**。<br>
中序遍历的本质就是**第2次到达当前节点时打印**。<br>
后序遍历的本质就是**第3次到达当前节点时打印**。


#### 使用非递归的方式遍历二叉树

##### 1.先序遍历
准备一个栈，然后流程如下
1. 将根节点入栈，栈不空就一直遍历
2. 弹出栈顶元素并给cur，弹出就打印。
3. 如果有右子树，右子树入栈，如果有左子树，左子树入栈(先入左再入右)
4. 不断重复2和3步骤，直到栈弹空。

理解：对于每一颗子树来说，都是先根节点入栈，再弹出，然后右子树入栈再左子树入栈。所以弹出时是
先弹出根，再左再右，每颗子树都是如此，所以整体的顺序就是先序遍历的顺序。


代码如下：
```go
// Pre 先序遍历
func (r *UnRecursiveTraversalBT) Pre(root *Node) {
	if root == nil {
		return
	}
	// 创建一个栈，并先把根节点压入
	stack := class_03.NewMyStack[*Node]()
	stack.Push(root)
	for !stack.IsEmpty() {
		cur := stack.Pop()
		// 出栈就打印
		fmt.Printf("%d ", cur.Value)
		// 有右子树，就入栈
		if cur.Right != nil {
			stack.Push(cur.Right)
		}
		// 有左子树，就入栈
		if cur.Left != nil {
			stack.Push(cur.Left)
		}
	}
	fmt.Println()
}
```

##### 2.后续遍历
从先序遍历的流程，我们用栈实现了先头再左再右的先序遍历顺序打印，用的方式是头入栈之后出栈，然后将头的右左子树分别入栈。

那么我们也可以实现先头再右再左的打印，方式是弹出头后，先入栈左子树，再入栈右子树。

进一步，上面的流程是**一出栈就打印**，如果我们在上面的基础上改动，一出栈就不打印，而是压入另一个栈。整个事情做完之后，再将另一个栈依次打印。

那么，最后打印的顺序是 头右左 的逆序，也就是 左右头，也就实现了后序遍历。

代码如下：
```go
// Pos1 后序遍历
func (r *UnRecursiveTraversalBT) Pos1(root *Node) {
	if root == nil {
		return
	}
	s1 := class_03.NewMyStack[*Node]()
	s2 := class_03.NewMyStack[*Node]()
	s1.Push(root)
	for !s1.IsEmpty() {
		head := s1.Pop()
		// 只要出栈，不打印，而是压入另一个栈
		s2.Push(head)
		// 弹出后依次压入左和右，实现整体 头 右 左 的顺序弹出
		if head.Left != nil {
			s1.Push(head.Left)
		}
		if head.Right != nil {
			s1.Push(head.Right)
		}
	}
	// 所有事情做完，依次将s2弹出
	for !s2.IsEmpty() {
		fmt.Printf("%d ", s2.Pop().Value)
	}
}
```

##### 3.中序遍历
中序遍历是先左子树，然后头节点，最后右子树。对于不管多高的二叉树，**最先遍历到的，一定是左边界的最后一个节点**，然后是头节点和右子树。<br>
所以中序遍历的本质是，将整颗树按照左边界做了一个拆分。

中序遍历的流程如下：

准备一个栈和一个cur变量，初始时cur指向根节点，循环条件是**栈不为空或者cur不为空**（栈为空且cur为空，就退出）
1. 如果cur不为空，cur入栈，cur跳到cur的左子树。
2. 如果cur为空，则栈弹出一个节点给cur接收，同时打印，同时cur指向cur的右子树。
3. 重复上述过程，直到cur为空且栈也弹空了，退出。

具体实例：
```
我们以这颗树为例：
      1      
    /   \    
  2       3  
 / \     / \ 
4   5   6   7
1. 初始cur不断往左边界走，直到走到4，一直入栈，stack = 1 2 4  栈顶是4，此时cur走到4的左孩子，是空
2. 弹出4打印，栈是 1 2，cur指向4的右孩子，cur又是空
3. 弹出2打印，栈是 1，cur指向2的右孩子为5，不为空，5入栈，栈是 1 5，cur来到5的左孩子，是空
4. 弹出5打印，栈是 1，cur指向5的右孩子为空
5. 弹出1打印，栈是空，cur指向1的右孩子，是3
6. 3入栈，栈是3，cur指向3的左孩子6
7. 6入栈，栈是3 6，cur指向6的左孩子，为空
8. 弹出6打印，栈是3，cur指向6的右孩子为空
9. 弹出3打印，栈为空，cur指向3的右孩子7
10.7入栈，栈是7，cur指向7的左孩子，是空
11.弹出7打印，cur指向7的右孩子，是空，此时栈是空，cur也是空，循环退出。
至此，依次打印了 4 2 5 1 6 3 7
```
代码如下：
```go
// In 中序遍历
func (r *UnRecursiveTraversalBT) In(root *Node) {
	if root == nil {
		return
	}
	// 创建一个栈，如果当前节点有左孩子，就压入，并不断往左边界靠
	stack := class_03.NewMyStack[*Node]()
	cur := root
	for !stack.IsEmpty() || cur != nil {
		if cur != nil {
			stack.Push(cur)
			cur = cur.Left
		} else {
			cur = stack.Pop()
			fmt.Printf("%d ", cur.Value)
			cur = cur.Right
		}
	}
	fmt.Println()
}
```

##### 3.后序遍历
准备两个栈`s1`和`s2`，