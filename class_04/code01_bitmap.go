package class_04

// Bitmap 位图
type Bitmap struct {
	arr []int64
	max int64
}

func NewBitmap(maxValue int64) *Bitmap {
	return &Bitmap{
		arr: make([]int64, (maxValue+64)>>6), // 数组长度：(maxValue + 64) / 64
		max: maxValue,
	}
}

// Add 添加一个数到位图中
func (b *Bitmap) Add(v int64) {
	// 不在限定范围内的，直接忽略
	if v > b.max || v < 0 {
		return
	}
	// 先找到这个数在数组的第几个数
	//index := v / 64
	// 要移动的位数，比如100，在数组的第1个数中的第36位 100 - 1 * 64 = 32
	// step := v - index*64
	// step := v % 64  // 相当于取模运算，v % 64 含义是 v 除以 64 的余数，与 v - index * 64 等价
	// 将0左移step位后，或到数组中的对应位置的数
	//b.arr[index] |= 1 << step

	// 精简写法：
	// v % 64 与 v & 63 等价 因为 & 比 % 运算快多了
	// 原因：64是7位二进制数 1000000，v % 64 就是将 v 的前6位的1保留，从第7位开始往后的全部清零
	// 比如2进制 010 1101101 % 64 是 000 0101101
	// 同样的数  010 1101101 & 63，因为63的二进制是 000 0111111
	// 010 1101101 &
	// 000 0111111 =
	// 000 0101101 正好也是保留了前6位，后面的全部清零，所以  v % 64 = v & 63 完全等价
	b.arr[v>>6] |= 1 << (v & 63)
}

// Remove 从位图中移除一个数
func (b *Bitmap) Remove(v int64) {
	// 不在限定范围内的，直接忽略
	if v > b.max || v < 0 {
		return
	}
	if !b.Exist(v) {
		return
	}
	// 先找到这个数在数组的第几个数
	//index := v / 64
	// 要移动的位数，比如100，在数组的第1个数中的第36位 100 - 1 * 64 = 32
	//step := v - index*64
	// 将0左移step位后，亦或到数组中的对应位置的数（亦或能抹掉这个位置的1）
	// b.arr[index] ^= 1 << step

	// 精简写法，一行搞定，两种写法都行，假设第4位的1（从0开始）需要删除掉
	// 亦或
	//  10110011
	// ^00010000
	// =10100011

	// 取反相与：00010000 取反后是 11101111 （只有第4位是0）
	//  10110011
	// &11101111
	// =10100011 结果是相等的
	//b.arr[v>>6] ^= 1 << (v & 63)
	b.arr[v>>6] &= ^(1 << (v & 63)) // ^ 在前面是取反操作
}

// Exist 判断一个数是否加入到了位图中
func (b *Bitmap) Exist(v int64) bool {
	// 先找到这个数在数组的第几个数
	// index := v / 64
	// 要移动的位数，比如100，在数组的第1个数中的第36位 100 - 1 * 64 = 32
	// step := v - index*64

	// 判断这个位上是否是1，将这个数 & 只有这位是1的数，判断结果是否是0
	return b.arr[v>>6]&(1<<(v&63)) != 0
}
