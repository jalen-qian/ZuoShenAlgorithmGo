# 使用位运算实现加减乘除
实现思路：先将两个数“无进位相加”，然后再算出进位信息，将进位信息 + 无进位相加的结果
此时发现还是需要+运算，但是进位信息会一直往高位移动，我们可以不断重复这个过程，直到进位信息变为全是0。
ps: 无进位相加，就是亦或运算  进位信息，就是与运算之后，往左移动一位。
计算进位信息示例如下：
```
  001011010
+ 010010011
= 011101101
ps: 只有第1位和第4位上，需要进位，那么进位信息应该是:
  000100010
```
我们具体举个例子：算 46 + 20 = 66 (46的二进制是`00101110`  20的二进制是`00010100`)

我们假设a'是无进位相加  b'是进位信息，则
```
a' = 00101110
   ^ 00010100
   = 00111010
b' = 00101110
   & 00010100 = 00000100 再左移一位
   = 00001000
则原式 = a' + b'（无进位相加之后，再加上进位信息的数）

由于我们计算机还是不能用加法，我们将这个过程再来一遍，则 
a'' = 00111010
    ^ 00001000
    = 00110010
b'' = 00111010
    & 00001000 = 00001000 再左移一位
    = 00010000
原式= a'' + b''，我们继续算
a''' = 00110010 ^ 00010000 = 00100010
b''' = 00110010 & 00010000 << 1 = 00100000
原式= a''' + b'''
a'''' = 00100010 ^ 00100000 = 00000010
b'''' = 00100010 & 00100000 << 1 = 01000000
所以，原式 = a'''' + b''''
继续算
a''''' = 00000010 ^ 01000000 = 01000010
b''''' = 00000010 & 01000000 << 1 = 00000000
```
此时，原式 = a''''' + b'''''，由于b'''''变成了0，所以a'''''就是
最终的值，我们验算下，a'''''的值是 `2^6 + 2^1 = 64 + 2 = 66` **正好是要求的结果**

事实上，计算机底层实现加法运算的流程，就是上面的这个流程。而实现其他运算都可以用加法来拼接而成

## 用位运算实现减法
我们实现了加法，那么要求 a - b = a + (-b)，而-b 就是 **b取反之后，再 + 1**，而加我们已经实现了，所以
```
a - b = add(a, add(^b, 1))
```
## 用位运算实现乘法
乘法是多个相同的数相加，也可以转换成加法
a * b = a + a + a + ... +a ps:b个a
但是这种方法比较耗性能，如果数比较大，则加法会进行很多次，也就是算法是O(N)的，
有没有办法转换成O(1)的呢？

还有一种是类似我们竖式计算的方法，只不过转换成了二进制
我们竖式计算一个数的方式如下：
```
    78
*   56
=  468
  390
= 4308 
```

> 总结规律：每位上的数，都分别乘以上面的数，并且左移1位（10进制左移1位就是乘以10）
> 
> 然后再将所有的数相加。

这里每次都用位上的数乘以上面的数，不是用到了乘法吗？但是请注意，我们用的是二进制，只会
出现0或者1，当出现0时，直接忽略，出现1时，1乘以任何数都是它本身，所以相当于将上面的数
左移下面的数出现的位数就行了，只进行了移位运算，没有进行乘法运算。下面举个例子
```
     0110111
    *0011010
=    0000000
+   0110111
+  0000000
+ 0110111
+0110111

也就是将乘法转换成3个数的加法
```
> 那算法流程是怎么样的呢？
> 
> 判断b的最右1位是否是1（判断方法是 & 1 判断是否为0），是则将原始的a值左移i位后叠加
> 
举例，流程如下：
```
a = 0111  7（10进制）
b = 0101  5（10进制）
ans = 0
1) b & 1 != 0，说明最后1位是1，则 ans += 0111， b又移1位 b=0010
2) b & 1 == 0，说明最后1位是0，则不处理，b继续又移1位 b=0001
3) b & 1 != 0，说明最后1位是1，则ans += 011100（a左移两位），b继续又移动一位 b = 0000
此时b为0了，说明b中没有任何的1了，不需要再计算
ans =   0111
     +011100
    = 100011
转换成十进制是  1 + 2 + 32 = 35 计算正确
```
可以看到，这种计算方法，计算次数是b中包含的1的个数，最多也不会超过64个，所以时间复杂度是O(1)


## 用位运算实现除法
乘法

